Antes de aplicar la imputación por nombre, estoy realizando una imputación semántica por objeto y categoría del contrato con el fin de ir completando los códigos CIIU (CIIU_final) que es un código que me permitirá identificar el riesgo par actividad económica, es 3 si son actividades que puedan estar relacionadas con LAFT, actualmente hago esto:

# imputación por similitud semántica

library(dplyr)
library(stringr)
library(tidyr)
library(text2vec)

# Paso 1: Crear campo combinado y filtrar registros válidos
base_referencia <- proveedores_ciiu_imputado %>%
  filter(!is.na(Objeto_contrato), !is.na(Categoria_contrato), !is.na(CIIU_final)) %>%
  mutate(texto_combinado = paste(Objeto_contrato, Categoria_contrato, sep = " ")) %>%
  select(texto_combinado, CIIU_final)

# Paso 2: Vectorizar con TF-IDF
tokens <- word_tokenizer(base_referencia$texto_combinado)
it <- itoken(tokens, progressbar = FALSE)
vocab <- create_vocabulary(it)
vectorizer <- vocab_vectorizer(vocab)
dtm <- create_dtm(it, vectorizer)
tfidf <- TfIdf$new()
dtm_tfidf <- tfidf$fit_transform(dtm)

# Paso 3: Función para imputar por similitud semántica
imputar_por_similitud <- function(objeto, categoria) {
  if (is.na(objeto) | is.na(categoria)) return(NA)
  
  texto <- paste(objeto, categoria, sep = " ")
  texto_tokens <- word_tokenizer(texto)
  it_query <- itoken(texto_tokens, progressbar = FALSE)
  dtm_query <- create_dtm(it_query, vectorizer)
  dtm_query_tfidf <- tfidf$transform(dtm_query)
  
  similitudes <- sim2(dtm_query_tfidf, dtm_tfidf, method = "cosine")
  top_idx <- order(similitudes[1, ], decreasing = TRUE)[1:5]
  moda <- base_referencia$CIIU_final[top_idx] %>% na.omit() %>% table() %>% which.max()
  
  return(names(moda))
}

# Paso 4: Aplicar imputación
proveedores_ciiu_imputado <- proveedores_ciiu_imputado %>%
  mutate(
    CIIU_final = if_else(
      is.na(CIIU_final) & !is.na(Objeto_contrato) & !is.na(Categoria_contrato),
      mapply(imputar_por_similitud, Objeto_contrato, Categoria_contrato),
      CIIU_final
    )
  )


mean(is.na(proveedores_ciiu_imputado$CIIU_final))

pero quiero evitar ambigüedades o falsos positivos.

Algunos ejemplos son:


MCOD_1	CIIU_final (antes)	Tipo_Industria	Objeto_contrato	Categoria_contrato	CIIU_final (despues)
TRAFIGURA MARKETING COLOM	4661	OTRAS FIRMAS JURIDICAS	CONTRATO IMPALA 2020- TRANSPORTE DE OLEF	PROCESOS EXCEPTUADOS - VCM	4661
TRAFIGURA ENERGY COLOMBIA	4661	OTRAS FIRMAS JURIDICAS	DILUYENTE PARA CRUDO	QUÍMICOS Y CATALIZADORES	4661
C.I. TRAFIGURA PETROLEUM	4661	NA	NA	NA	4661
TRAFIGURA PTE LTD	NA	EMPRESA EXTRANJERA	DEMORAS	DEMORAS	4290
TRAFIGURA MARITIME LOGIST	NA	EMPRESA EXTRANJERA	FLETE PROPANO SEP 13-15/2015	OTRAS CATEGORÍAS	6412
TRAFIGURA SECURITISATION	NA	NA	NA	NA	NA
TRAFIGURA TRADING LLC	NA	EMPRESA EXTRANJERA	XILENO IMPORTADO	QUÍMICOS Y CATALIZADORES	4669
TRAFIGURA ENVIRONMENTAL S	NA	NA	NA	NA	NA

después de esto hago la imputación por nombre

## imputacion por nombre

library(dplyr)
library(stringr)

# Función para obtener la moda con mayoría
moda_con_mayoria <- function(x, umbral = 0.05) {
  x <- na.omit(x)
  if (length(x) == 0) return(NA)
  tab <- table(x)
  moda <- names(tab)[which.max(tab)]
  prop <- max(tab) / sum(tab)
  if (prop >= umbral) return(moda) else return(NA)
}

# Limpiar y extraer nombre base (por ejemplo, "TRAFIGURA")
proveedores_ciiu_imputado2 <- proveedores_ciiu_imputado %>%
  mutate(
    MCOD_clean = str_squish(str_to_upper(MCOD_1)),
    nombre_base = str_extract(MCOD_clean, "^[A-Z]+")  # Extrae solo la primera palabra
  ) %>%
  group_by(nombre_base) %>%
  mutate(
    moda_valor = moda_con_mayoria(CIIU_final, umbral = 0.05),
    CIIU_final = if_else(is.na(CIIU_final), moda_valor, CIIU_final)
  ) %>%
  ungroup() %>%
  select(-MCOD_clean, -nombre_base, -moda_valor)


mean(is.na(proveedores_ciiu_imputado2$CIIU_final))
