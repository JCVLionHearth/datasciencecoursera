
Gracias por compartir tu flujo completo. EstÃ¡s haciendo una imputaciÃ³n bastante sofisticada en dos etapas: primero semÃ¡ntica y luego por nombre base, lo cual es una muy buena estrategia. El problema que identificas â€”que ciertos valores como 4661 no se estÃ¡n imputando correctamente a registros con nombres similares (como el grupo â€œTRAFIGURAâ€)â€” tiene que ver con cÃ³mo estÃ¡s extrayendo el nombre_base y cÃ³mo se calcula la moda. AquÃ­ te dejo una explicaciÃ³n detallada y una versiÃ³n corregida y mejorada del cÃ³digo:

â¸»

ğŸ” DiagnÃ³stico del problema
	1.	ExtracciÃ³n del nombre base (nombre_base):
	â€¢	EstÃ¡s usando str_extract(MCOD_clean, "^[A-Z]+"), que solo extrae la primera palabra. En el caso de TRAFIGURA MARKETING COLOM, nombre_base serÃ¡ "TRAFIGURA", pero si tienes espacios raros, sÃ­mbolos, o prefijos como C.I., podrÃ­as estar rompiendo agrupaciones correctas.
	2.	CÃ¡lculo de la moda:
	â€¢	EstÃ¡s usando moda_con_mayoria con un umbral = 0.05, es decir, con solo un 5% ya se acepta como mayorÃ­a. Eso no impone una restricciÃ³n fuerte, y puede seleccionar cÃ³digos poco representativos.
	â€¢	AdemÃ¡s, si hay empates, which.max() puede retornar el primero que encuentra, incluso si no es el mÃ¡s frecuente semÃ¡nticamente.

â¸»

âœ… Recomendaciones

1. Normaliza el nombre base con mÃ¡s robustez:

# Extrae la palabra clave mÃ¡s representativa (por ejemplo, TRAFIGURA o ECOPETROL)
extraer_nombre_base <- function(nombre) {
  nombre <- str_squish(str_to_upper(nombre))
  nombre <- str_replace_all(nombre, "C\\.I\\.|S\\.A\\.|LTDA|LTD|LLC|\\.|\\,", "")  # elimina siglas comunes
  palabras <- str_split(nombre, " ")[[1]]
  palabras <- palabras[nchar(palabras) > 3]  # descarta palabras muy cortas o poco informativas
  return(palabras[1])
}

2. Usa esa funciÃ³n en un mutate:

proveedores_ciiu_imputado2 <- proveedores_ciiu_imputado %>%
  mutate(nombre_base = sapply(MCOD_1, extraer_nombre_base)) %>%
  group_by(nombre_base) %>%
  mutate(
    moda_valor = moda_con_mayoria(CIIU_final, umbral = 0.30),  # sube el umbral a 30% o mÃ¡s
    CIIU_final = if_else(is.na(CIIU_final), moda_valor, CIIU_final)
  ) %>%
  ungroup() %>%
  select(-nombre_base, -moda_valor)


â¸»

ğŸ§ª Alternativa mÃ¡s precisa: ponderaciÃ³n con conteo

Si quieres una imputaciÃ³n mÃ¡s estricta, puedes cambiar el criterio de moda por nÃºmero absoluto de ocurrencias (no proporciÃ³n):

moda_por_frecuencia <- function(x, min_veces = 2) {
  x <- na.omit(x)
  if (length(x) == 0) return(NA)
  tab <- sort(table(x), decreasing = TRUE)
  if (tab[1] >= min_veces) return(names(tab)[1]) else return(NA)
}


â¸»

ğŸ“Š ValidaciÃ³n final

Puedes ver quÃ© registros siguen sin imputar y revisar si hay patrones:

filtro_no_imputados <- proveedores_ciiu_imputado2 %>%
  filter(is.na(CIIU_final))

table(filtro_no_imputados$Tipo_Industria)


â¸»

âœ… ConclusiÃ³n
	â€¢	EstÃ¡s haciendo muy bien el enfoque de imputaciÃ³n por etapas: semÃ¡ntica (TF-IDF) + nombre (cluster).
	â€¢	El problema puntual parece estar en la forma de extraer y agrupar por nombre.
	â€¢	Con una limpieza mÃ¡s robusta y un umbral de mayorÃ­a mÃ¡s exigente, deberÃ­as lograr que registros como TRAFIGURA ENVIRONMENTAL S se imputen correctamente con 4661, al igual que los demÃ¡s del grupo.

Â¿Quieres que prepare una versiÃ³n integrada del script completo con estas mejoras?

Antes de aplicar la imputaciÃ³n por nombre, estoy realizando una imputaciÃ³n semÃ¡ntica por objeto y categorÃ­a del contrato con el fin de ir completando los cÃ³digos CIIU (CIIU_final) que es un cÃ³digo que me permitirÃ¡ identificar el riesgo par actividad econÃ³mica, es 3 si son actividades que puedan estar relacionadas con LAFT, actualmente hago esto:

# imputaciÃ³n por similitud semÃ¡ntica

library(dplyr)
library(stringr)
library(tidyr)
library(text2vec)

# Paso 1: Crear campo combinado y filtrar registros vÃ¡lidos
base_referencia <- proveedores_ciiu_imputado %>%
  filter(!is.na(Objeto_contrato), !is.na(Categoria_contrato), !is.na(CIIU_final)) %>%
  mutate(texto_combinado = paste(Objeto_contrato, Categoria_contrato, sep = " ")) %>%
  select(texto_combinado, CIIU_final)

# Paso 2: Vectorizar con TF-IDF
tokens <- word_tokenizer(base_referencia$texto_combinado)
it <- itoken(tokens, progressbar = FALSE)
vocab <- create_vocabulary(it)
vectorizer <- vocab_vectorizer(vocab)
dtm <- create_dtm(it, vectorizer)
tfidf <- TfIdf$new()
dtm_tfidf <- tfidf$fit_transform(dtm)

# Paso 3: FunciÃ³n para imputar por similitud semÃ¡ntica
imputar_por_similitud <- function(objeto, categoria) {
  if (is.na(objeto) | is.na(categoria)) return(NA)
  
  texto <- paste(objeto, categoria, sep = " ")
  texto_tokens <- word_tokenizer(texto)
  it_query <- itoken(texto_tokens, progressbar = FALSE)
  dtm_query <- create_dtm(it_query, vectorizer)
  dtm_query_tfidf <- tfidf$transform(dtm_query)
  
  similitudes <- sim2(dtm_query_tfidf, dtm_tfidf, method = "cosine")
  top_idx <- order(similitudes[1, ], decreasing = TRUE)[1:5]
  moda <- base_referencia$CIIU_final[top_idx] %>% na.omit() %>% table() %>% which.max()
  
  return(names(moda))
}

# Paso 4: Aplicar imputaciÃ³n
proveedores_ciiu_imputado <- proveedores_ciiu_imputado %>%
  mutate(
    CIIU_final = if_else(
      is.na(CIIU_final) & !is.na(Objeto_contrato) & !is.na(Categoria_contrato),
      mapply(imputar_por_similitud, Objeto_contrato, Categoria_contrato),
      CIIU_final
    )
  )


mean(is.na(proveedores_ciiu_imputado$CIIU_final))

pero quiero evitar ambigÃ¼edades o falsos positivos.

Algunos ejemplos son:


MCOD_1	CIIU_final (antes)	Tipo_Industria	Objeto_contrato	Categoria_contrato	CIIU_final (despues)
TRAFIGURAÂ MARKETINGÂ COLOM	4661	OTRASÂ FIRMASÂ JURIDICAS	CONTRATOÂ IMPALAÂ 2020-Â TRANSPORTEÂ DEÂ OLEF	PROCESOSÂ EXCEPTUADOSÂ -Â VCM	4661
TRAFIGURAÂ ENERGYÂ COLOMBIA	4661	OTRASÂ FIRMASÂ JURIDICAS	DILUYENTEÂ PARAÂ CRUDO	QUÃMICOSÂ YÂ CATALIZADORES	4661
C.I.Â TRAFIGURAÂ PETROLEUM	4661	NA	NA	NA	4661
TRAFIGURAÂ PTEÂ LTD	NA	EMPRESAÂ EXTRANJERA	DEMORAS	DEMORAS	4290
TRAFIGURAÂ MARITIMEÂ LOGIST	NA	EMPRESAÂ EXTRANJERA	FLETEÂ PROPANOÂ SEPÂ 13-15/2015	OTRASÂ CATEGORÃAS	6412
TRAFIGURAÂ SECURITISATION	NA	NA	NA	NA	NA
TRAFIGURAÂ TRADINGÂ LLC	NA	EMPRESAÂ EXTRANJERA	XILENOÂ IMPORTADO	QUÃMICOSÂ YÂ CATALIZADORES	4669
TRAFIGURAÂ ENVIRONMENTALÂ S	NA	NA	NA	NA	NA

despuÃ©s de esto hago la imputaciÃ³n por nombre

## imputacion por nombre

library(dplyr)
library(stringr)

# FunciÃ³n para obtener la moda con mayorÃ­a
moda_con_mayoria <- function(x, umbral = 0.05) {
  x <- na.omit(x)
  if (length(x) == 0) return(NA)
  tab <- table(x)
  moda <- names(tab)[which.max(tab)]
  prop <- max(tab) / sum(tab)
  if (prop >= umbral) return(moda) else return(NA)
}

# Limpiar y extraer nombre base (por ejemplo, "TRAFIGURA")
proveedores_ciiu_imputado2 <- proveedores_ciiu_imputado %>%
  mutate(
    MCOD_clean = str_squish(str_to_upper(MCOD_1)),
    nombre_base = str_extract(MCOD_clean, "^[A-Z]+")  # Extrae solo la primera palabra
  ) %>%
  group_by(nombre_base) %>%
  mutate(
    moda_valor = moda_con_mayoria(CIIU_final, umbral = 0.05),
    CIIU_final = if_else(is.na(CIIU_final), moda_valor, CIIU_final)
  ) %>%
  ungroup() %>%
  select(-MCOD_clean, -nombre_base, -moda_valor)


mean(is.na(proveedores_ciiu_imputado2$CIIU_final))
