
Gracias por compartir el c√≥digo completo. A continuaci√≥n, te ayudo en tres partes:

‚∏ª

‚úÖ 1. Mejoras en la conversi√≥n de fechas

Actualmente usas:

read_pagos$`Fecha pago` <- as.Date(read_pagos$`Fecha pago`, tryFormats = c("%Y-%m-%d", "%d.%m.%Y"))

Esto puede fallar si hay formatos como "dd/mm/yyyy" o "mm/dd/yyyy". Te propongo esta versi√≥n m√°s robusta:

convertir_fecha <- function(fecha) {
  formatos <- c("%Y-%m-%d", "%d.%m.%Y", "%d/%m/%Y", "%m/%d/%Y")
  for (formato in formatos) {
    f <- as.Date(fecha, format = formato)
    if (!all(is.na(f))) return(f)
  }
  return(as.Date(NA))
}

read_pagos$`Fecha pago` <- sapply(read_pagos$`Fecha pago`, convertir_fecha)
read_pagos <- read_pagos %>% filter(!is.na(`Fecha pago`))


‚∏ª

‚úÖ 2. Versi√≥n basada en percentiles (reemplazo de œÉ/100)

El m√©todo de desviaci√≥n est√°ndar puede fallar cuando hay una gran dispersi√≥n, como en tu caso (m√≠nimo: 43 mil; m√°ximo: 207 millones). En lugar de dividir la desviaci√≥n est√°ndar entre 100, propongo agrupar pagos por percentiles, por ejemplo, de 10 en 10 (deciles).

üîÅ Reemplazo de la secci√≥n del ciclo por percentiles:

# Inicializar resultados
resultados <- list()

for (proveedor in unique(read_pagos$Acreedor)) {
  valores <- read_pagos %>%
    filter(Acreedor == proveedor) %>%
    pull(`Importe ML`)
  
  if (length(valores) < 10 || length(unique(valores)) == 1) {
    resultados[[length(resultados) + 1]] <- data.frame(
      Proveedor = proveedor,
      Percentil = NA,
      Frecuencia = NA,
      Orden = NA,
      Limite_Inferior = NA,
      Limite_Superior = NA,
      Mensaje = "Datos insuficientes o sin variaci√≥n"
    )
    next
  }
  
  # Calcular los percentiles
  percentiles <- quantile(valores, probs = seq(0, 1, by = 0.1), na.rm = TRUE)
  rangos <- data.frame(
    Limite_Inferior = head(percentiles, -1),
    Limite_Superior = tail(percentiles, -1),
    Orden = 1:10
  )
  
  # Contar frecuencia de pagos por rango
  rangos$Frecuencia <- sapply(1:nrow(rangos), function(i) {
    sum(valores >= rangos$Limite_Inferior[i] & valores <= rangos$Limite_Superior[i])
  })
  
  # Tomar los rangos m√°s frecuentes
  rangos <- rangos %>%
    arrange(desc(Frecuencia)) %>%
    head(n_top_rangos) %>%
    mutate(Proveedor = proveedor, Mensaje = "", Percentil = paste0("P", Orden*10))
  
  resultados[[length(resultados) + 1]] <- rangos
}

df_resultados <- do.call(rbind, resultados)

üß† ¬øPor qu√© percentiles es mejor que desviaci√≥n est√°ndar?

Criterio	Desviaci√≥n est√°ndar	Percentiles
Robustez ante extremos	Afectado por valores at√≠picos	No se ve afectado
Interpretabilidad	T√©cnica para usuarios t√©cnicos	F√°cil de comunicar: ‚Äúel 10% de los pagos est√°n entre X y Y‚Äù
Homogeneidad	Depende de la varianza	Siempre divide en grupos con cantidades similares de observaciones
Adaptabilidad	Requiere calibraci√≥n (œÉ/100, œÉ/1000‚Ä¶)	No requiere calibraci√≥n

üëâ En tu caso, dado el rango de pagos de 43 mil a 207 millones, los percentiles te ayudar√°n a identificar zonas de concentraci√≥n reales, sin que un valor alto o bajo sesgue la segmentaci√≥n.

‚∏ª

‚úÖ 3. Siguiente paso sugerido: etiquetas de categor√≠a de pago con NLP

Una vez identificado el rango frecuente por proveedor, podr√≠as usar text2vec, tidytext, topicmodels o udpipe para clasificar los textos asociados a cada pago y ver qu√© categor√≠as aparecen m√°s en los pagos recurrentes.

‚∏ª

¬øDeseas que te integre el nuevo c√≥digo completo con percentiles directamente sobre tu base read_pagos, o prefieres que te lo d√© modular por partes?


# Cargar librer√≠as necesarias
library(readxl)
library(dplyr)
library(openxlsx)
library('xlsx')
library('writexl')
library("readxl")
library(ggplot2)


# Rutas y archivos
path1 <- "//10.11.46.150/cdn/MATRIZ/Originales/Pagos/Hist√≥rico"
archivos1 <- c("Pagos_2020.xlsx", "Pagos_2021.xlsx", "Pagos_2022.xlsx", 
               "Pagos_2023.xlsx", "Pagos_2024_1s.xlsx", "Pagos_2024_2s.xlsx")

path2 <- "//10.11.46.150/cdn/JCVR/Rutinas de Monitoreo/Pagos Recurrentes"
archivos2 <- c("pagos_2025_enero-mayo.xlsx")

# Diccionario de homologaci√≥n
homologar_nombres <- function(nombre) {
  nombre <- trimws(nombre)
  switch(nombre,
         "V√≠a de pago" = "Via de pago",
         "VP" = "Via de pago",
         "NÔΩ∫ doc." = "Nro documento",
         "N¬∫ documento" = "Nro documento",
         "Fecha doc." = "Fecha documento",
         "Fecha de documento" = "Fecha documento",
         "Clase de documento" = "Clase",
         "Clase" = "Clase",
         "Fe.contabilizaci√≥n" = "Fecha contab.",
         "Fe.contab." = "Fecha contab.",
         "Fecha de pago" = "Fecha pago",
         "Fecha pago" = "Fecha pago",
         "Sociedad" = "Sociedad",
         "Soc." = "Sociedad",
         "Compens." = "Fecha compensacion",
         "Fecha compensaci√≥n" = "Fecha compensacion",
         "Importe en moneda local" = "Importe ML",
         "Importe en ML" = "Importe ML",
         nombre)
}

# Funci√≥n para leer y homologar columnas
leer_y_homologar <- function(path, archivo) {
  df <- read_excel(file.path(path, archivo))
  colnames(df) <- sapply(colnames(df), homologar_nombres)
  return(df)
}

# Leer todos los archivos
dfs1 <- lapply(archivos1, function(f) leer_y_homologar(path1, f))
dfs2 <- lapply(archivos2, function(f) leer_y_homologar(path2, f))
todos <- c(dfs1, dfs2)

# Encontrar columnas comunes
columnas_comunes <- Reduce(intersect, lapply(todos, names))

# Convertir columnas comunes a texto y unir
unidos <- bind_rows(lapply(todos, function(df) {
  df_comun <- df[, columnas_comunes]
  df_comun[] <- lapply(df_comun, as.character)
  return(df_comun)
}))

# Guardar resultado
#write.xlsx(unidos, file = "Pagos_Unificados_Homologados.xlsx", sheetName = "Pagos", row.names = FALSE)

cat("‚úÖ Archivo combinado guardado como 'Pagos_Unificados_Homologados.xlsx'\n")


# Identificaci√≥n de pagos recurrentes

options(scipen = 999)  # Evita notaci√≥n cient√≠fica en general

# Convertir la columna 'Acreedor' a texto y eliminar NA
read_pagos <- unidos %>%
  mutate(Acreedor = as.character(Acreedor)) %>%
  filter(!is.na(Acreedor))

# Filtrar por clase 'ZP' o 'KZ' y excluir un acreedor espec√≠fico
read_pagos <- read_pagos %>%
  filter((Clase == "ZP" | Clase == "KZ") & Acreedor != "3037711")


# Limpiar la columna 'Importe en ML'
read_pagos$`Importe ML` <- gsub("[\\$,\\.]", "", read_pagos$`Importe ML`)
read_pagos$`Importe ML` <- sapply(read_pagos$`Importe ML`, function(x) {
  if (grepl("\\(", x)) {
    -as.numeric(gsub("[\\(\\)]", "", x))
  } else {
    as.numeric(x)
  }
})

# Filtrar valores positivos
read_pagos <- read_pagos %>%
  filter(`Importe ML` > 0)

# Cu√°ntos rangos (top N)
n_top_rangos <- 2

# Convertir fecha 
# Normalizar formato de fecha en la columna 'Fecha pago'
read_pagos$`Fecha pago` <- as.Date(read_pagos$`Fecha pago`, tryFormats = c("%Y-%m-%d", "%d.%m.%Y"))
sum(is.na(read_pagos$`Fecha pago`))  # Cantidad de fechas no convertidas


# Eliminar fechas inv√°lidas
read_pagos <- read_pagos %>% filter(!is.na(`Fecha pago`))


# Inicializar resultados
resultados <- list()
proveedores <- unique(read_pagos$Acreedor)

for (proveedor in proveedores) {
  valores <- read_pagos %>%
    filter(Acreedor == proveedor) %>%
    pull(`Importe ML`)
  
  if (length(valores) < 2 || length(unique(valores)) == 1) {
    resultados[[length(resultados) + 1]] <- data.frame(
      Proveedor = proveedor,
      Rango = NA,
      Frecuencia = NA,
      Orden = NA,
      Limite_Inferior = NA,
      Limite_Superior = NA,
      Mensaje = "Datos insuficientes o sin variaci√≥n"
    )
    next
  }
  
  desv <- sd(valores)
  paso <- ifelse(desv != 0, desv / 100, 1)
  breaks <- seq(0, max(valores) + paso, by = paso)
  
  # Asignar cada valor a un rango
  rangos_cut <- cut(valores, breaks = breaks, include.lowest = TRUE, right = FALSE)
  
  # Contar ocurrencias por rango
  tabla_rangos <- as.data.frame(table(rangos_cut)) %>%
    arrange(desc(Freq))
  
  # Tomar los n_top_rangos m√°s frecuentes
  top_rangos <- head(tabla_rangos, n_top_rangos)
  
  
  if (nrow(top_rangos) > 0) {
    # Extraer los l√≠mites inferiores y superiores del rango
    limites <- do.call(rbind, lapply(as.character(top_rangos$rangos_cut), function(r) {
      r <- gsub("\\[|\\]|\\(|\\)", "", r)  # Elimina corchetes y par√©ntesis
      partes <- strsplit(r, ",")[[1]]
      as.numeric(trimws(partes))
    }))
    
    resultados[[length(resultados) + 1]] <- data.frame(
      Proveedor = rep(proveedor, nrow(top_rangos)),
      Rango = as.character(top_rangos$rangos_cut),
      Frecuencia = top_rangos$Freq,
      Orden = seq_len(nrow(top_rangos)),
      Limite_Inferior = limites[, 1],
      Limite_Superior = limites[, 2],
      Mensaje = ""
    )
  }
}

# Combinar
df_resultados <- do.call(rbind, resultados)

# Guardar
write.xlsx(df_resultados, file = "//10.11.46.150/cdn/JCVR/Rutinas de Monitoreo/Pagos Recurrentes/Top_rangos_recurrentes_por_Acreedor.xlsx", row.names = FALSE)


# Agregar columna con el orden del rango recurrente
read_pagos$Orden_Rango <- NA # Inicializar columna

for (i in 1:nrow(df_resultados)) {
  proveedor <- df_resultados$Proveedor[i]
  lim_inf <- df_resultados$Limite_Inferior[i]
  lim_sup <- df_resultados$Limite_Superior[i]
  orden <- df_resultados$Orden[i]
  
  idx <- which(read_pagos$Acreedor == proveedor &
                 read_pagos$`Importe ML` >= lim_inf &
                 read_pagos$`Importe ML` < lim_sup)
  
  read_pagos$Orden_Rango[idx] <- orden
}


# Guardar
write.xlsx(read_pagos, file = "//10.11.46.150/cdn/JCVR/Rutinas de Monitoreo/Pagos Recurrentes/Pagos_finales_filtrados.xlsx", row.names = FALSE)

# filtro

listado <- c("3003498", "3003858", "3001460", "3002331", "3003576", "3014594", 
             "3002439", "3002887", "3004354", "3002146", "3002891", "3005539", 
             "3016196", "3016049", "3001928", "3007498", "3002052", "3014412", 
             "3003079", "3009281", "3002825", "3037760", "3003896", "3001739", 
             "4002", "3033907", "3019787", "3002837", "3003933", "3018879")


pagos_busqueda<-read_pagos %>%
  filter(Acreedor %in% listado)

# Guardar
write.xlsx(pagos_busqueda, file = "Pagos_filtrados.xlsx", row.names = FALSE)

pagos_busqueda$`Fecha pago` <- as.Date(pagos_busqueda$`Fecha pago`, tryFormats = c("%Y-%m-%d", "%d.%m.%Y"))

library(writexl)
write_xlsx(pagos_busqueda, path = "Pagos_filtrados.xlsx")

