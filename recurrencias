Perfecto. Vas a reemplazar solo una parte espec√≠fica dentro del for (proveedor in proveedores) ‚Äî exactamente donde actualmente tienes este bloque:

if (nrow(top_rangos) > 0) {
  resultados[[length(resultados) + 1]] <- data.frame(
    Proveedor = rep(proveedor, nrow(top_rangos)),
    Rango = as.character(top_rangos$rangos_cut),
    Frecuencia = top_rangos$Freq,
    Orden = seq_len(nrow(top_rangos)),
    Mensaje = ""
  )
}

üëá Reempl√°zalo por este nuevo bloque completo:

if (nrow(top_rangos) > 0) {
  # Extraer los l√≠mites inferiores y superiores del rango
  limites <- do.call(rbind, lapply(as.character(top_rangos$rangos_cut), function(r) {
    r <- gsub("\\[|\\]|\\(|\\)", "", r)  # Elimina corchetes y par√©ntesis
    partes <- strsplit(r, ",")[[1]]
    as.numeric(trimws(partes))
  }))
  
  resultados[[length(resultados) + 1]] <- data.frame(
    Proveedor = rep(proveedor, nrow(top_rangos)),
    Rango = as.character(top_rangos$rangos_cut),
    Frecuencia = top_rangos$Freq,
    Orden = seq_len(nrow(top_rangos)),
    Limite_Inferior = limites[, 1],
    Limite_Superior = limites[, 2],
    Mensaje = ""
  )
}

‚úî Resultado:

Tu df_resultados tendr√° ahora esta estructura de columnas:

Proveedor | Rango | Frecuencia | Orden | Limite_Inferior | Limite_Superior | Mensaje

Y luego, el write.xlsx() seguir√° funcionando igual, exportando todos los valores con los l√≠mites claros y sin notaci√≥n cient√≠fica.

¬øTe gustar√≠a que te d√© tambi√©n un ejemplo de c√≥mo se ve una fila de resultado final?


# con mas de un nivel de orden de rangos
options(scipen = 999)  # Evita notaci√≥n cient√≠fica en general

# Convertir la columna 'Acreedor' a texto y eliminar NA
read_pagos <- unidos %>%
  mutate(Acreedor = as.character(Acreedor)) %>%
  filter(!is.na(Acreedor))

# Filtrar por clase 'ZP' o 'KZ' y excluir un acreedor espec√≠fico
read_pagos <- read_pagos %>%
  filter((Clase == "ZP" | Clase == "KZ") & Acreedor != "3037711")


# Limpiar la columna 'Importe en ML'
read_pagos$`Importe ML` <- gsub("[\\$,\\.]", "", read_pagos$`Importe ML`)
read_pagos$`Importe ML` <- sapply(read_pagos$`Importe ML`, function(x) {
  if (grepl("\\(", x)) {
    -as.numeric(gsub("[\\(\\)]", "", x))
  } else {
    as.numeric(x)
  }
})

# Filtrar valores positivos
read_pagos <- read_pagos %>%
  filter(`Importe ML` > 0)

# Cu√°ntos rangos (top N)
n_top_rangos <- 2

# Convertir fecha 
read_pagos$`Fecha pago` <- as.Date(read_pagos$`Fecha pago`)

# Eliminar fechas inv√°lidas
read_pagos <- read_pagos %>% filter(!is.na(`Fecha pago`))

# Inicializar resultados
resultados <- list()
proveedores <- unique(read_pagos$Acreedor)

for (proveedor in proveedores) {
  valores <- read_pagos %>%
    filter(Acreedor == proveedor) %>%
    pull(`Importe ML`)
  
  if (length(valores) < 2 || length(unique(valores)) == 1) {
    resultados[[length(resultados) + 1]] <- data.frame(
      Proveedor = proveedor,
      Rango = NA,
      Frecuencia = NA,
      Orden = NA,
      Mensaje = "Datos insuficientes o sin variaci√≥n"
    )
    next
  }
  
  desv <- sd(valores)
  paso <- ifelse(desv != 0, desv / 100, 1)
  breaks <- seq(0, max(valores) + paso, by = paso)
  
  # Asignar cada valor a un rango
  rangos_cut <- cut(valores, breaks = breaks, include.lowest = TRUE, right = FALSE)
  
  # Contar ocurrencias por rango
  tabla_rangos <- as.data.frame(table(rangos_cut)) %>%
    arrange(desc(Freq))
  
  # Tomar los n_top_rangos m√°s frecuentes
  top_rangos <- head(tabla_rangos, n_top_rangos)
  
  
  if (nrow(top_rangos) > 0) {
    resultados[[length(resultados) + 1]] <- data.frame(
      Proveedor = rep(proveedor, nrow(top_rangos)),
      Rango = as.character(top_rangos$rangos_cut),
      Frecuencia = top_rangos$Freq,
      Orden = seq_len(nrow(top_rangos)),
      Mensaje = ""
    )
  }
}

# Combinar
df_resultados <- do.call(rbind, resultados)

# Guardar
write.xlsx(df_resultados, file = "Top_rangos_recurrentes_por_proveedor.xlsx", row.names = FALSE)
