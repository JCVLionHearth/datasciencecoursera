\section{Creación y activación de un entorno virtual en Visual Studio Code}

Para garantizar que el aplicativo funcione correctamente, es necesario crear un entorno virtual que contenga todas las dependencias necesarias. A continuación, se describen los pasos para crear y activar dicho entorno en Visual Studio Code.

\subsection{Paso 1: Instalación de Python}
Primero, es necesario tener instalado Python en el sistema. Se recomienda instalar la última versión disponible en el sitio oficial \href{https://www.python.org/downloads/}{https://www.python.org/downloads/}.

\subsection{Paso 2: Crear el entorno virtual}

1. Abre Visual Studio Code y abre la carpeta de tu proyecto.
2. Abre la terminal integrada en Visual Studio Code, lo puedes hacer desde el menú \textit{Terminal} > \textit{New Terminal}.
3. Una vez en la terminal, navega a la carpeta de tu proyecto (si no estás ya en ella), usando el comando \texttt{cd}.

\begin{lstlisting}[language=bash]
cd ruta/al/proyecto
\end{lstlisting}

4. Para crear el entorno virtual, ejecuta el siguiente comando:
\begin{lstlisting}[language=bash]
python -m venv venv
\end{lstlisting}

\noindent Aquí \texttt{venv} es el nombre del entorno virtual que se creará. Puedes cambiarlo por cualquier otro nombre si lo prefieres.

\subsection{Paso 3: Activar el entorno virtual}

\textbf{En Windows:}  
Ejecuta el siguiente comando en la terminal para activar el entorno virtual:
\begin{lstlisting}[language=bash]
.\venv\Scripts\activate
\end{lstlisting}

\textbf{En macOS o Linux:}  
Ejecuta el siguiente comando para activar el entorno virtual:
\begin{lstlisting}[language=bash]
source venv/bin/activate
\end{lstlisting}

\subsection{Paso 4: Verificar que el entorno esté activado}
Cuando el entorno esté activado, deberías ver el prefijo del entorno virtual (por ejemplo, \texttt{(venv)}) antes de la ruta en la terminal. Esto indicará que estás trabajando dentro del entorno virtual.

\subsection{Paso 5: Instalación de dependencias}
Con el entorno activado, ahora es posible instalar las dependencias necesarias. Puedes hacer esto utilizando el archivo \texttt{requirements.txt}, que contiene todas las bibliotecas requeridas para el proyecto. Para instalar dichas dependencias, ejecuta el siguiente comando en la terminal:

\begin{lstlisting}[language=bash]
pip install -r requirements.txt
\end{lstlisting}

\noindent Este comando instalará todas las bibliotecas listadas en el archivo \texttt{requirements.txt}.

\subsection{Paso 6: Desactivación del entorno virtual}
Una vez que hayas terminado de trabajar, puedes desactivar el entorno virtual usando el comando:
\begin{lstlisting}[language=bash]
deactivate
\end{lstlisting}
\noindent Esto cerrará el entorno virtual y te devolverá a tu entorno de sistema operativo normal.

\appendix
\section{Paquetes Necesarios}

A continuación, se describen los paquetes necesarios para la ejecución del proyecto, los cuales están listados en el archivo \texttt{requirements.txt}. Para instalar estos paquetes se puede utilizar el siguiente comando:

\begin{verbatim}
pip install -r requirements.txt
\end{verbatim}

\subsection{Paquetes y Explicaciones}

\begin{itemize}
    \item \texttt{Flask} (versión X.X.X): Es un microframework para Python utilizado para desarrollar aplicaciones web. Se usa en este proyecto para crear el servidor web que aloja la interfaz de la aplicación, permitiendo la interacción del usuario con las simulaciones.
    \item \texttt{pandas} (versión X.X.X): Biblioteca esencial para la manipulación y análisis de datos. En este proyecto, se utiliza para gestionar los datos de entrada y salida, incluyendo la manipulación de archivos Excel y la creación de reportes.
    \item \texttt{numpy} (versión X.X.X): Biblioteca fundamental para cálculos numéricos. Es clave en la generación de simulaciones de Monte Carlo, al proporcionar soporte para la creación de distribuciones numéricas y matrices de datos.
    \item \texttt{scipy} (versión X.X.X): Extiende las capacidades de \texttt{numpy} con funciones adicionales para estadísticas, optimización y simulación. En este proyecto se utiliza para generar distribuciones normales y triangulares en las simulaciones.
    \item \texttt{matplotlib} (versión X.X.X): Utilizada para la generación de gráficos. En esta aplicación, se emplea para visualizar los resultados de las simulaciones.
    \item \texttt{openpyxl} (versión X.X.X): Permite la manipulación de archivos Excel. Se utiliza para exportar los resultados de las simulaciones a formato Excel, que luego puede ser descargado por el usuario.
\end{itemize}

\section{Código del Proyecto}

A continuación se incluye un extracto del código fuente de la aplicación. Se describen los principales componentes y su función dentro del sistema.

\subsection{Estructura de la Aplicación}

La aplicación está construida usando \texttt{Flask}, con las siguientes rutas clave:
\begin{itemize}
    \item \texttt{app.py}: Archivo principal de la aplicación. Define las rutas y los controladores que manejan la lógica del lado del servidor.
    \item \texttt{templates/}: Carpeta donde se alojan los archivos HTML que conforman la interfaz gráfica de usuario.
    \item \texttt{static/}: Contiene los archivos estáticos como hojas de estilo CSS o scripts JavaScript.
\end{itemize}

\subsection{Fragmentos de Código con Comentarios}

\begin{verbatim}
from flask import Flask, render_template, request
import pandas as pd
import numpy as np
from scipy.stats import norm, triang
import matplotlib.pyplot as plt

# Inicialización de la aplicación Flask
app = Flask(__name__)

# Definición de la ruta principal de la aplicación
@app.route('/')
def index():
    # Renderiza el archivo HTML principal
    return render_template('index.html')

# Ruta para procesar los archivos Excel subidos por el usuario
@app.route('/upload', methods=['POST'])
def upload_file():
    # Se obtiene el archivo subido por el usuario
    file = request.files['file']
    
    # Se lee el archivo Excel utilizando pandas
    df = pd.read_excel(file)
    
    # Aquí se ejecutaría la simulación de Monte Carlo utilizando numpy y scipy
    # Ejemplo: simulación de distribución normal
    mean = df['Impacto'].mean()
    std_dev = df['Impacto'].std()
    simulacion_normal = np.random.normal(mean, std_dev, 1000)
    
    # Retorna el resultado al HTML para su visualización
    return render_template('result.html', data=simulacion_normal)
\end{verbatim}

\begin{itemize}
    \item \texttt{from flask import Flask, render_template, request}: Importa las funciones necesarias para iniciar el servidor y manejar peticiones HTTP. Flask es el núcleo del backend de esta aplicación.
    \item \texttt{from scipy.stats import norm, triang}: Se importa el módulo \texttt{scipy.stats} que proporciona funciones estadísticas, incluidas las distribuciones normal y triangular, utilizadas para las simulaciones de Monte Carlo.
    \item \texttt{app = Flask(\_\_name\_\_)}: Inicializa la aplicación Flask. Esto es necesario para que Flask comience a escuchar solicitudes y sirva las rutas.
    \item \texttt{def index()}: Esta función maneja la ruta raíz (`/`) de la aplicación y renderiza el archivo HTML principal.
    \item \texttt{def upload\_file()}: Esta ruta maneja la carga de archivos por parte del usuario y procesa los archivos Excel para ejecutar las simulaciones.
    \item \texttt{np.random.normal(mean, std\_dev, 1000)}: Utiliza la función \texttt{normal()} de \texttt{numpy} para generar una simulación de Monte Carlo basada en una distribución normal, con media y desviación estándar calculadas a partir de los datos cargados.
\end{itemize}

A continuación te propongo las secciones para el análisis de la simulación de Monte Carlo y la configuración de archivos que deseas. Se incluirán tanto las fórmulas matemáticas de las distribuciones utilizadas como la configuración de los archivos de riesgos. Puedes ajustar según lo que consideres necesario.

### Sección 1: Análisis y Modelos Matemáticos para la Simulación de Monte Carlo

```latex
\section{Análisis de la Simulación de Monte Carlo}
La simulación de Monte Carlo es una técnica estadística que utiliza el muestreo aleatorio para obtener resultados aproximados de problemas complejos. En este caso, se utiliza para estimar los límites de responsabilidad contractual (LRC) bajo diferentes escenarios de riesgo.

\subsection{Distribución Triangular}
La distribución triangular se utiliza para representar variables inciertas cuando se conocen tres valores: el mínimo, el máximo y el más probable. La función de densidad de probabilidad (PDF) para una variable \(X\) con distribución triangular se define como:

\[
f(x) = 
\begin{cases} 
\frac{2(x - a)}{(b - a)(c - a)}, & a \leq x < c \\
\frac{2(b - x)}{(b - a)(b - c)}, & c \leq x \leq b
\end{cases}
\]

Donde:
\begin{itemize}
    \item \(a\) es el valor mínimo (optimista).
    \item \(b\) es el valor máximo (pesimista).
    \item \(c\) es el valor más probable.
\end{itemize}

La simulación de Monte Carlo genera números aleatorios para la variable de interés utilizando esta distribución y evalúa el resultado bajo diferentes escenarios.

\subsection{Distribución Normal}
En escenarios donde se dispone de un valor esperado y una desviación estándar, se utiliza la distribución normal para modelar el riesgo. La función de densidad de probabilidad para la distribución normal está dada por:

\[
f(x) = \frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{(x - \mu)^2}{2\sigma^2}}
\]

Donde:
\begin{itemize}
    \item \(\mu\) es el valor esperado.
    \item \(\sigma\) es la desviación estándar.
\end{itemize}

El modelo genera escenarios de riesgo en base a los valores esperados y sus desviaciones, permitiendo una estimación del LRC bajo distintos niveles de confianza.
```

### Sección 2: Configuración de los Archivos de Riesgo

```latex
\section{Configuración de Archivos para la Simulación}
Los archivos de entrada para el aplicativo deben estar en formato CSV o Excel y seguir una estructura definida. A continuación, se describe la configuración para cada tipo de distribución.

\subsection{Archivo para la Distribución Triangular}
Este archivo contiene los parámetros para los escenarios de riesgo utilizando la distribución triangular. El formato del archivo incluye las siguientes columnas:

\begin{verbatim}
| Riesgo | Impacto Mínimo | Impacto Máximo | Impacto Probable | Probabilidad Mínima | Probabilidad Máxima | Probabilidad Probable |
\end{verbatim}

Un ejemplo de este archivo sería:

\begin{verbatim}
| Riesgo 1 | 50000 | 200000 | 100000 | 0.1 | 0.5 | 0.3 |
| Riesgo 2 | 10000 | 50000  | 30000  | 0.05 | 0.2 | 0.1 |
\end{verbatim}

\subsection{Archivo para la Distribución Normal}
Este archivo contiene los parámetros para la configuración del riesgo basado en la distribución normal. Las columnas que se deben incluir son las siguientes:

\begin{verbatim}
| Riesgo | Valor Esperado (Impacto) | Desviación Estándar (Impacto) | Valor Esperado (Probabilidad) | Desviación Estándar (Probabilidad) |
\end{verbatim}

Un ejemplo sería:

\begin{verbatim}
| Riesgo 1 | 120000 | 25000 | 0.3 | 0.05 |
| Riesgo 2 | 40000  | 10000 | 0.15 | 0.02 |
\end{verbatim}

Estos archivos se cargarán en el sistema para la configuración de los riesgos y la simulación de escenarios.

\section{Visualización de Resultados}
El aplicativo genera una visualización gráfica de los resultados de las simulaciones, incluyendo los límites de confianza para cada escenario, las predicciones y los umbrales de riesgo. A continuación se presentan ejemplos de gráficos generados por el sistema para la toma de decisiones basada en el análisis de riesgos.
```

Con estas secciones puedes incluir las fórmulas matemáticas, la configuración de los archivos y una breve descripción de cómo se visualizan los resultados en la interfaz. Si necesitas agregar más detalle o cambiar algo, házmelo saber.

\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

\title{Estimación del Límite de Responsabilidad Contractual (LRC) mediante Simulaciones de Monte Carlo}
\author{Nombre del Autor}
\date{Septiembre 2024}

\begin{document}

\maketitle

\begin{abstract}
Este documento tiene como objetivo describir en detalle el funcionamiento de una aplicación prototipo que estima el Límite de Responsabilidad Contractual (LRC) mediante simulaciones estadísticas, incluyendo modelos de Monte Carlo. El propósito de este documento es servir tanto como una guía de usuario para personas no expertas, como un manual replicable para especialistas que deseen implementar una metodología similar.
\end{abstract}

\tableofcontents
\newpage

\section{Introducción}
La estimación del Límite de Responsabilidad Contractual (LRC) es una tarea crítica en la gestión de riesgos. Para este propósito, se ha desarrollado una aplicación prototipo que utiliza simulaciones estadísticas y métodos probabilísticos para calcular el LRC, considerando diferentes escenarios de riesgo y distribuciones estadísticas. Este documento describe el funcionamiento de dicha aplicación y su metodología subyacente.

\section{Objetivo}
El objetivo de esta aplicación es proporcionar una herramienta que permita a los usuarios calcular el LRC mediante métodos de simulación. Las simulaciones están basadas en distribuciones de probabilidad para el impacto y la probabilidad de ocurrencia de riesgos, permitiendo una estimación más precisa y adaptable.

\section{Metodología}

\subsection{Modelos Estadísticos Utilizados}
El cálculo del LRC se basa en modelos estadísticos que representan diferentes escenarios de riesgo. Se pueden considerar dos tipos de entradas:
\begin{itemize}
    \item Distribuciones triangulares, que consideran un valor optimista, un valor probable y un valor pesimista para el impacto y la probabilidad.
    \item Distribución normal, en la cual se asume un valor esperado para el impacto, junto con la probabilidad esperada y su desviación estándar.
\end{itemize}

La aplicación realiza simulaciones de Monte Carlo para generar múltiples escenarios posibles, estimando así percentiles que ayudan en la toma de decisiones sobre el límite de responsabilidad.

\subsection{Simulaciones de Monte Carlo}
Las simulaciones de Monte Carlo permiten generar una distribución de resultados basada en los parámetros de entrada (impacto y probabilidad). Para cada simulación, se generan miles de iteraciones que simulan diferentes escenarios de riesgos. A partir de estas simulaciones, se generan percentiles que permiten al usuario evaluar el riesgo y establecer un límite de responsabilidad contractual adecuado.

La función de simulación sigue el siguiente modelo:
\begin{equation}
X_i = \text{Impacto} \times \text{Probabilidad}
\end{equation}

Donde \( X_i \) es el resultado de cada iteración de la simulación. Los valores de \( \text{Impacto} \) y \( \text{Probabilidad} \) varían según las distribuciones definidas por el usuario.

\section{Arquitectura de la Aplicación}
La aplicación está desarrollada utilizando el marco Flask en Python, y se ejecuta en un entorno virtual. La arquitectura está compuesta por los siguientes componentes:

\begin{itemize}
    \item Archivos estáticos, que incluyen recursos como hojas de estilo y archivos JavaScript.
    \item Plantillas HTML para la interfaz gráfica del usuario.
    \item Un archivo Python que maneja la lógica de backend, incluyendo las simulaciones de Monte Carlo y la integración con archivos Excel.
\end{itemize}

El flujo de trabajo de la aplicación es el siguiente:
\begin{enumerate}
    \item El usuario carga un archivo de riesgos en formato Excel.
    \item La aplicación procesa el archivo, genera simulaciones y muestra los resultados mediante gráficos interactivos (Plotly).
    \item El usuario puede descargar los resultados en formato Excel.
\end{enumerate}

\section{Conclusiones}
Esta aplicación prototipo proporciona una herramienta robusta para la estimación del LRC mediante simulaciones estadísticas. Permite a los usuarios analizar diferentes escenarios de riesgo y tomar decisiones informadas basadas en modelos probabilísticos.

\section{Descargo de Responsabilidad}
Este documento y la aplicación descrita son prototipos en desarrollo y no deben utilizarse para la toma de decisiones críticas sin una validación adicional. La aplicación está diseñada para fines educativos y de investigación, y su implementación en situaciones reales debe realizarse con precaución.
\end{document}

Hola, quiero crear una nota tecnica, en donde explique a detalle el funcionamiento de la aplicación (prototipo) en la que permite visualizar los intervalos en los que estaría la estimación del limite de responsabilidad contractual (LRC) por medio de simulaciones.
1. Deseo que esta nota tecnica esta hecha en latex
2. Muestre matemáticamente los modelos usados para la simulación de monte carlo
3. Defina la metodología usada.
4. Describa la configuración de los archivos de riesgo que deben ser cargados para que el prototipo estinme el LRC (tablas en látex)
5. Describa la arquitectura utilizada para su desarrollo.

Actualmente la arquitectura esta hecha en visual studio code:
tiene un entorno virtual: lrc_env
una carpeta static, en donde esta un archivo style.css y una carpeta de imagenes
una carpeta llamada templates, en donde estan los archivos html: index_lrc.html, form_lrc.html y results_lrc.html
y el archivo python que desarrolla la aplicación: appLRC.py

quiero mostrar la arquitectura o configuración de las carpeta tambien en látex

Necesito indicar en la nota tecnica: la metodología, los modelos estadisticos usados, objetivos, justificación, un disclaimer en el que se indique que la herramienta es un prototipo y que los resultados (que será una curva de percentiles) dependerá de los riesgos cargados y todo lo necesario para eliminar responsabilidades (lo mas polite posible), la forma en la que deberia usarse, la arquitectura de la aplicacion y herramientas necesarias para ejecutarlo.
la idea es que el documento pueda ser entendido por cualquiera y que además permita a usuarios expertos replicar la metodología en sus computadores.

Te comparto la configuración de los archivos para que conozcas el desarrollo y metodología usada en la aplicación.


#1. Archivo Python: appLRC.py

from flask import Flask, request, render_template, send_file, make_response, redirect, url_for, flash, session
import pandas as pd
import numpy as np
import plotly.graph_objs as go
import plotly.io as pio
import io
from scipy.stats import triang
import os

app = Flask(__name__)

app.secret_key = 'supersecretkey'
app.config['UPLOAD_FOLDER'] = 'uploads'

def validar_archivo_normal(df):
    required_columns = {'I_esp', 'P_esp','std_impact','std_prob','Frecuencia'}
    return required_columns.issubset(df.columns)

def validar_archivo_triangular(df):
    required_columns = {'I_min','P_min','I_esp','P_esp','I_max','P_max','Frecuencia'}
    return required_columns.issubset(df.columns)

@app.route('/')
def index():
    return render_template('index_lrc.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    file = request.files['file']

    if not file:
        flash('No file selected')
        return redirect(url_for('index'))
    
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
    file.save(filepath)
    df = pd.read_excel(filepath)
    
    session['filepath'] = filepath
    session['file_columns'] = list(df.columns)
    
    flash('Archivo de Riesgos Cargado Satisfactoriamente!','success')
    return render_template('form_lrc.html', columns=df.columns.tolist(), data=df.to_dict(orient='records'))



@app.route('/simulate', methods=['POST'])
def simulate():
    df_data = request.form.getlist('data')
    df = pd.DataFrame(eval(df_data[0]))
    
    presupuesto = float(request.form['presupuesto'])
    n_sim = int(request.form['n_sim'])
    seed = int(request.form['seed'])
    
    if 'filepath' not in session:
        flash('No file uploaded','danger')
        return redirect(url_for('index'))
    
    filepath = session['filepath']
    df = pd.read_excel(filepath)

    np.random.seed(seed)
    
    def triangular_simulation(row):
        P_min, P_esp, P_max = float(row['P_min']), float(row['P_esp']), float(row['P_max'])
        I_min, I_esp, I_max = float(row['I_min']), float(row['I_esp']), float(row['I_max'])
        Frecuencia = float(row['Frecuencia'])
        prob_sim = triang.rvs((P_esp - P_min) / (P_max - P_min), loc=P_min, scale=P_max - P_min, size=n_sim)
        impact_sim = triang.rvs((I_esp - I_min) / (I_max - I_min), loc=I_min * Frecuencia, scale=I_max * Frecuencia - I_min * Frecuencia, size=n_sim)
        return prob_sim * impact_sim

    def normal_simulation(row):
            P_esp= float(row['P_esp'])
            I_esp= float(row['I_esp'])
            std_prob= float(row['std_prob'])
            std_impact= float(row['std_impact'])
            Frecuencia = float(row['Frecuencia'])
            prob_sim = np.random.normal(P_esp, std_prob, size=n_sim)
            impact_sim = np.random.normal(I_esp * Frecuencia, std_impact * Frecuencia,size= n_sim)
            # Asegurarse de que las probabilidades estén en el rango [0, 1]
            prob_sim = np.clip(prob_sim, 0, 1)
            return prob_sim * impact_sim

    choice=request.form['choice']
    if choice=='funcion1':
        if not validar_archivo_normal(df):
            flash('El archivo seleccionado no es válido para la distribución normal','danger')
            flash('Para la distribución normal, el archivo debe tener los campos: I_esp, P_esp, std_impact, std_prob, Frecuencia','info')
            return render_template('form_lrc.html', columns=df.columns.tolist(), data=df.to_dict(orient='records'))
        lrc_total = np.sum([normal_simulation(row) for idx, row in df.iterrows()], axis=0)
    elif choice=='funcion2':
        if not validar_archivo_triangular(df):
            flash('El archivo seleccionado no es válido para la distribución triangular','danger')
            flash('Para la distribución triangular, el archivo debe tener los campos: I_min, P_min, I_esp, P_esp, I_max, P_max, Frecuencia','info')
            return render_template('form_lrc.html', columns=df.columns.tolist(), data=df.to_dict(orient='records'))
        lrc_total = np.sum([triangular_simulation(row) for idx, row in df.iterrows()], axis=0)
    else:
        flash('Distribución no válida')
        return render_template('form_lrc.html', columns=df.columns.tolist(), data=df.to_dict(orient='records'))

    lrc_final = lrc_total
    lrc_ajustada = ((lrc_final/presupuesto))
    lrc_ajustada =lrc_ajustada*100

    percentiles = np.percentile(lrc_ajustada, np.arange(0, 101))
    percentiles_df = np.percentile(lrc_ajustada, np.arange(0, 101,5))
    mean_lrc = np.mean(lrc_ajustada)
    
    percentil_90 = np.percentile(lrc_ajustada, 90)

    percentiles_table = pd.DataFrame({'Percentil': np.arange(0, 101,5), 'Porcentaje_LRC': percentiles_df})
    percentiles_table['Porcentaje_LRC']=percentiles_table['Porcentaje_LRC'].apply(lambda x: f'{int(x):,}') # dandole formato a la tabla

    # Gráfico de la distribución de la suma asegurada ajustada
    fig = go.Figure()

    fig.add_trace(go.Histogram(x=lrc_ajustada,nbinsx=100,name='Simulaciones % LRC'))
    fig.add_trace(go.Scatter(x=[mean_lrc,mean_lrc],
                             y=[0,max(np.histogram(lrc_ajustada,bins=50)[0])],
                             mode="lines",
                             name=f'LRC esperado: {mean_lrc:.2f} %',
                             line=dict(color='red',dash='dash')
                             ))
    xaxis = dict(title="% LRC")
    yaxis = dict(title="Frecuencia simulada")
    fig.update_layout(title="Histograma", xaxis=xaxis, yaxis=yaxis)
    graphJSON = pio.to_json(fig)

    # Gráfico de percentiles
    fig2=go.Figure()

    fig2.add_trace(go.Scatter(
        x=np.arange(0,101),
        y=percentiles,
        mode='lines',
        name='Percentiles',
        line=dict(color='blue')
    ))

    fig2.add_trace(go.Scatter(
        x=[0,100],
        y=[percentil_90,percentil_90],
        mode='lines',
        name='Percentil 90',
        line=dict(color='red',dash='dash')
    ))

    fig2.update_layout(title="Percentiles del % LRC", xaxis_title='Percentiles', yaxis_title='% LRC',showlegend=True)
    graphJSON2 = pio.to_json(fig2)

    # Conversión de la tabla de percentiles a formato html
    percentiles_table_html = percentiles_table.to_html(index=False,classes='table table-striped table-bordered text-center',justify='center')
    df_table_html = pd.DataFrame(lrc_ajustada, columns=['Simulaciones']).to_html(index=False)

    return render_template('results_lrc.html', mean_lrc=mean_lrc,
                           percentiles_table=percentiles_table_html, df_table=df_table_html,
                           data=df.to_dict(orient='records'), percentiles_table_data=percentiles_table.to_dict(orient='records'),lrc_ajustada_data=lrc_ajustada.tolist(),
                           graphJSON=graphJSON,graphJSON2=graphJSON2)

@app.route('/download', methods=['POST'])
def download_file():
    # Obtener datos desde el formulario
    try:
        df_data = request.form.getlist('data')
        percentiles_table_data = request.form.getlist('percentiles_table_data')
        lrc_ajustada_data = request.form.getlist('lrc_ajustada_data')

        # Asegurarse de que los datos sean válidos y no estén vacíos
        if not df_data or not percentiles_table_data or not lrc_ajustada_data:
            flash("Los datos proporcionados no son válidos o están vacíos", "danger")
            return redirect(url_for('index'))

        # Convertir las listas JSON a DataFrames
        df = pd.DataFrame(eval(df_data[0]))
        percentiles_table = pd.DataFrame(eval(percentiles_table_data[0]))
        lrc_ajustada = pd.DataFrame(eval(lrc_ajustada_data[0]), columns=['Lrc Ajustada'])

        # Crear un flujo de bytes en memoria
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            # Escribir cada DataFrame en una hoja separada del archivo Excel
            df.to_excel(writer, index=False, sheet_name='Input Data')
            percentiles_table.to_excel(writer, index=False, sheet_name='Percentiles')
            lrc_ajustada.to_excel(writer, index=False, sheet_name='Simulaciones')

        # Asegurarse de que el buffer esté en la posición inicial
        output.seek(0)

        # Crear una respuesta para enviar el archivo Excel generado
        response = make_response(output.read())
        response.headers['Content-Disposition'] = 'attachment; filename=simulation_results.xlsx'
        response.headers['Content-type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'

        return response

    except Exception as e:
        # Capturar cualquier error y mostrar un mensaje de error adecuado
        flash(f"Ocurrió un error al generar el archivo: {str(e)}", "danger")
        return redirect(url_for('index'))

@app.route('/')
def form():
    return render_template('index_lrc.html')

if __name__ == '__main__':
    app.run(debug=True)

Archivos Html:
#2 index_lrc.html
En esta página se cargan los archivos de excel de acuerdo con la configuaración de riesgos que se ha definido anteriormente

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <title>Simulación de LRC</title>
</head>

<body>
    <div class="container mt-5 card shadow-lg">
        <h1 class="mb-4">Simulación de Limite de Responsabilidad</h1>
        <div class="card-header bg-primary text-white">
            <h4 class="mb-0">Cargar archivo de riesgos</h4>
        </div>
        <div class="card-body">
            <form action="/upload" method="post" enctype="multipart/form-data">
                <div class="mb-3">
                    <label for="file" class="form-label">Subir archivo Excel</label>
                    <input class="form-control" type="file" name="file" id="file" required>
                </div>
                <button type="submit" class="btn btn-primary btn-block">Cargar archivo</button>
                <br>
            </form>
            <br>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>

#3 form_lrc.html

En esta hoja se configura los parametros de entrada para la simulación, tales como presupuesto, numero de simulaciones y la semilla (este valor es para auditorias y reproducidad de la simulación)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parametros-Simulación Monte Carlo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <div class="row justify-content-center align-items-center h-100">
            <div class="col-md-8">
                <div class="card shadow-lg">
                    <div class="card-header bg-primary text-white">
                        <h2>Parametros de simulación</h2>
                    </div>
                    <div class="card-body  btn-block">
                        <form action="/simulate" method="post">
                            {% with messages = get_flashed_messages(with_categories=true) %}
                                {% if messages %}
                                    {% for category,message in messages %}
                                    <div class="alert alert-{{ category }}">
                                        {{ message }}
                                    </div>
                                    {% endfor %}
                                {% endif %}
                            {% endwith %}
                            
                            <div class="form-group">
                                <label for="presupuesto">Presupuesto (MUSD):</label>
                                <input type="number" class="form-control" id="presupuesto" name="presupuesto" step="0.01" value="1" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="n_sim">Número de Simulaciones:</label>
                                <input type="number" class="form-control" id="n_sim" name="n_sim" value="10000" required>
                            </div>
                            <div class="form-group">
                                <label for="seed">Semilla (Seed):</label>
                                <input type="number" class="form-control" id="seed" name="seed" value="1234" required>
                            </div>
                            <br>
                            <div class="card-body shadow p-3 mb-5 bg-white rounded">
                            <div class="form-group">
                                <div class="card-header bg-primary text-white">
                                <h4>Configuración del archivo de Riesgos</h4>
                                </div>
                                <input type="radio" id="funcion1" name="choice" value="funcion1" required>
                                <label for ="funcion1">Análisis con distribución Normal (Valor esperado y Desviación)</label>
                                <br>
                                <input type="radio" id="funcion2" name="choice" value="funcion2">
                                <label for ="funcion2">Análisis con distribución Triangular (Escenarios: Pesimista, Probable, Optimista)</label>
                            </div>
                            </div>
                            <input type="hidden" name="data" value="{{ data }}">
                           
                            <button type="submit" class="btn btn-success">Simular</button>
                         </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>

#4 results_lrc.html

En esta hoja se presentan los rangos en los que podria variar la estimacion del limite de responsabilidad contractual (LRC), definida por perecentiles, la idea aqui es que el usuario final seleccione el valor más apropiado de LRC, de acuerdo con su apetito de riesgo, adversidad al riesgo. quiero dejar claro en el documento que los resultados serán una herramienta para ayudar a seleccionar el mejor LRC, pero este valor dependerá de la configuración de los riesgos cargados y de los impactos y probabilidades definidas.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monte Carlo Simulation - Results</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <div class="card-header bg-primary text-white">
    <h2>Resultados Simulación Limite de Responsabilidad</h2>
    </div>
    

    <div class="card-body shadow p-3 mb-5 bg-white rounded">
        <h3>Parámetros ingresados</h3>
        <p for="presupuesto" >Presupuesto (MUSD): $ {{ request.form['presupuesto'] }}</p>
        <p for="n_sim">Número de Simulaciones: {{ request.form['n_sim'] }}</p>
        <p for="seed">Semilla (Seed): {{ request.form['seed'] }}</p>
        
    </div>
    
    <div class="row mt-4 card-body shadow p-3 mb-5 bg-white rounded">
        <div class="col-md-6">
            <h3>Distribución LRC simulado</h3>
            <div id="graph"></div>
        </div>
        <div class="col-md-6">
            <h3>Percentiles de % LRC</h3>
            <div id="graph2"></div>
        </div>
    </div>
        
    <div class="card-body shadow p-3 mb-5 bg-white rounded">
        <h3>Curva de percentiles para el LRC (%)</h3>
        <div>{% autoescape false %}{{ percentiles_table|safe }}{% endautoescape %}</div>
    </div> 
    
    <div class="row mt-4 card-body shadow p-3 mb-5 bg-white rounded">
    <form action="/download" method="post">
        <input type="hidden" name="data" value="{{ data }}">
        <input type="hidden" name="percentiles_table_data" value="{{ percentiles_table_data }}">
        <input type="hidden" name="lrc_ajustada_data" value="{{ lrc_ajustada_data }}">
        <button type="submit" class="btn btn-success">Descargar Resultados Excel</button>
    </form>
    </div>

    <div class="card shadow p-3 mb-5 bg-white rounded">
        <button class="btn btn-primary" onclick="window.print()">Guardar como PDF</button>
        <br>
        <button class="btn btn-primary" onclick="window.location.href='{{ url_for('form') }}'">Volver a simular</button>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script>
        var graphJSON = {{ graphJSON | safe }};
        Plotly.newPlot('graph', graphJSON.data, graphJSON.layout);
    </script>
    <script>
        var graphJSON2 = {{ graphJSON2 | safe }};
        Plotly.newPlot('graph2', graphJSON2.data, graphJSON2.layout);
    </script>
</body>
</html>
