Desde una mirada actuarial, quiero implementar modelos para pricing, en particular para el ramo de automÃ³viles. Actualmente las tÃ©cnicas mas utilizadas son los modelos lineales generalizado (glm), para identificar la severidad y la probabilidad, por lo que se estima cada una mendiante una modelaciÃ³n de acuerdo con el comportamiento de los datos y al final se obtiene un producto probabilidad por severidad, pero el precio va a depender de las caracterÃ­sticas del auto, del conductor y otras, tambiÃ©n del histÃ³rico de siniestros.

Necesito me ayudes a crear un proyecto e visual studio code para que haga lo siguiente:
1. Un script en Python completo que permita generar una base de siniestros ficticia de automÃ³viles, la cual incluya la suma asegurada por tipo de daÃ±o, el valor del siniestro, el tipo de daÃ±o (perdida parcial, robo, perdida total), las caracterÃ­sticas del auto (color, peso, cilindraje, puestos, modelo y las demÃ¡s necesarias), las caracterÃ­sticas del conductor (edad, genero, estado civil y las demÃ¡s necesarias para este ejercicio). la base debe abordar todo lo necesario para realizar el ejercicio de pricing.
2. otro script en Python completo que permita realizar la modelaciÃ³n de la severidad y de la probabilidad y ademÃ¡s que permita establecer las variables optimas de cada modelo, graficos, definiciones de funciones link y todo lo necesario que consideres para el desarrollo completo del ejercicio de pricing.
3. otro script tipo cotizador en el que se pueda ingresar datos para cotizar la prima de riesgo, de acuerdo con la suma asegurada del cliente

El ejercicio debe ser lo mÃ¡s parecido con la realidad, es decir el objetivo es que yo como actuario mediante la modelaciÃ³n pueda estimar la probabilidad y la severidad mediante los valores estimados del modelo glm

Perfecto, Juan. Vamos a estructurar este proyecto actuarial de pricing en Python con enfoque realista, utilizando modelos lineales generalizados (GLM), dividido en tres scripts:

â¸»

ðŸ—‚ Estructura del Proyecto en Visual Studio Code

auto_insurance_pricing/
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ siniestros_ficticios.csv         # Datos sintÃ©ticos generados
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ 1_generar_datos.py               # Generador de datos ficticios
â”‚   â”œâ”€â”€ 2_modelos_glm.py                 # Modelos GLM de severidad y frecuencia
â”‚   â””â”€â”€ 3_cotizador_prima.py            # Cotizador de prima de riesgo
â”‚
â”œâ”€â”€ requirements.txt                     # Paquetes necesarios
â””â”€â”€ README.md                            # DescripciÃ³n del proyecto


â¸»

ðŸ“Œ 1. 1_generar_datos.py: Generador de datos ficticios

Generaremos una base realista de siniestros. IncluirÃ¡ caracterÃ­sticas del vehÃ­culo, conductor, tipo de daÃ±o, suma asegurada y valor del siniestro.

ðŸ§© Variables clave
	â€¢	tipo_danio: perdida parcial, total, robo
	â€¢	valor_siniestro: severidad
	â€¢	frecuencia: se infiere luego por modelado de eventos
	â€¢	auto: marca, modelo, peso, cilindraje, color, puestos, valor comercial
	â€¢	conductor: edad, gÃ©nero, estado civil, experiencia, historial
	â€¢	suma_asegurada: por tipo de daÃ±o

âœ… CÃ³digo

import pandas as pd
import numpy as np
import random
from faker import Faker

fake = Faker()
np.random.seed(42)

def generar_datos(n=5000):
    tipo_danio = ['perdida parcial', 'robo', 'perdida total']
    colores = ['rojo', 'azul', 'blanco', 'negro', 'gris', 'plateado']
    marcas = ['Toyota', 'Mazda', 'Chevrolet', 'Renault', 'Ford']
    modelos = list(range(2005, 2024))

    datos = []
    for _ in range(n):
        marca = random.choice(marcas)
        modelo = random.choice(modelos)
        valor_comercial = np.random.randint(20_000_000, 100_000_000)
        peso = np.random.randint(900, 2500)
        cilindraje = np.random.randint(1000, 3500)
        puestos = random.choice([2, 4, 5, 7])
        color = random.choice(colores)

        edad = np.random.randint(18, 80)
        genero = random.choice(['M', 'F'])
        estado_civil = random.choice(['soltero', 'casado', 'divorciado'])
        experiencia = np.random.randint(0, max(edad - 16, 1))
        historial = np.random.poisson(0.3)

        tipo = random.choice(tipo_danio)
        suma_asegurada = valor_comercial * random.uniform(0.7, 1.1)
        prob_siniestro = 0.1 + 0.01 * historial + 0.005 * (80 - edad)  # mayor riesgo jÃ³venes y con historial
        hubo_siniestro = np.random.binomial(1, min(prob_siniestro, 1))

        valor_siniestro = 0
        if hubo_siniestro:
            if tipo == 'perdida parcial':
                valor_siniestro = np.random.uniform(0.1, 0.5) * suma_asegurada
            elif tipo == 'robo':
                valor_siniestro = np.random.uniform(0.5, 1.0) * suma_asegurada
            else:
                valor_siniestro = suma_asegurada

        datos.append({
            'marca': marca,
            'modelo': modelo,
            'valor_comercial': valor_comercial,
            'peso': peso,
            'cilindraje': cilindraje,
            'puestos': puestos,
            'color': color,
            'edad': edad,
            'genero': genero,
            'estado_civil': estado_civil,
            'experiencia': experiencia,
            'historial': historial,
            'tipo_danio': tipo if hubo_siniestro else 'sin_siniestro',
            'suma_asegurada': suma_asegurada,
            'valor_siniestro': valor_siniestro,
            'hubo_siniestro': hubo_siniestro
        })

    return pd.DataFrame(datos)

if __name__ == "__main__":
    df = generar_datos()
    df.to_csv("../data/siniestros_ficticios.csv", index=False)
    print("âœ… Datos ficticios guardados.")


â¸»

ðŸ“Œ 2. 2_modelos_glm.py: Modelos GLM

Utilizaremos statsmodels para modelar:
	â€¢	Frecuencia (probabilidad de siniestro): GLM binomial
	â€¢	Severidad (monto del siniestro): GLM Gamma (con link log)

âœ… CÃ³digo

import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("../data/siniestros_ficticios.csv")

# Preprocesamiento
df['genero'] = df['genero'].astype('category')
df['estado_civil'] = df['estado_civil'].astype('category')
df['color'] = df['color'].astype('category')
df['marca'] = df['marca'].astype('category')

# ----------------------------
# MODELO DE FRECUENCIA
# ----------------------------
formula_frecuencia = "hubo_siniestro ~ edad + C(genero) + experiencia + historial + valor_comercial + cilindraje + peso"
modelo_frec = smf.glm(formula=formula_frecuencia, data=df, family=sm.families.Binomial()).fit()
print("\n--- Modelo Frecuencia (GLM Binomial) ---\n")
print(modelo_frec.summary())

# ----------------------------
# MODELO DE SEVERIDAD
# ----------------------------
df_severos = df[df["hubo_siniestro"] == 1].copy()
formula_severidad = "valor_siniestro ~ edad + C(genero) + experiencia + valor_comercial + cilindraje + peso + historial"
modelo_sev = smf.glm(formula=formula_severidad, data=df_severos,
                     family=sm.families.Gamma(link=sm.genmod.families.links.log())).fit()

print("\n--- Modelo Severidad (GLM Gamma) ---\n")
print(modelo_sev.summary())

# ----------------------------
# GRAFICOS
# ----------------------------
def graficar_residuos(modelo, titulo):
    plt.figure()
    plt.scatter(modelo.fittedvalues, modelo.resid_response)
    plt.axhline(0, color='red', linestyle='--')
    plt.xlabel("Valores ajustados")
    plt.ylabel("Residuos")
    plt.title(titulo)
    plt.show()

graficar_residuos(modelo_frec, "Residuos Frecuencia")
graficar_residuos(modelo_sev, "Residuos Severidad")

# Guardar modelos si se desea usar en el cotizador
modelo_frec.save("../scripts/modelo_frecuencia.pickle")
modelo_sev.save("../scripts/modelo_severidad.pickle")


â¸»

ðŸ“Œ 3. 3_cotizador_prima.py: Cotizador

âœ… CÃ³digo

import pandas as pd
import statsmodels.api as sm
import numpy as np

# Cargar modelos entrenados
modelo_frec = sm.load("modelo_frecuencia.pickle")
modelo_sev = sm.load("modelo_severidad.pickle")

# Datos de entrada
nuevo = pd.DataFrame([{
    'edad': 30,
    'genero': 'M',
    'experiencia': 10,
    'historial': 1,
    'valor_comercial': 60000000,
    'cilindraje': 1600,
    'peso': 1200
}])

# Deben coincidir las dummies con el modelo
nuevo['genero'] = nuevo['genero'].astype('category')

# Estimaciones
prob = modelo_frec.predict(nuevo)[0]
severidad = modelo_sev.predict(nuevo)[0]

prima_riesgo = prob * severidad

print(f"ðŸ§® Probabilidad estimada de siniestro: {prob:.3f}")
print(f"ðŸ’¥ Severidad estimada: ${severidad:,.0f}")
print(f"ðŸ’° Prima de riesgo sugerida: ${prima_riesgo:,.0f}")


â¸»

ðŸ“¦ requirements.txt

pandas
numpy
faker
matplotlib
seaborn
statsmodels


â¸»

Â¿Quieres que te empaquete esto como ZIP listo para descargar? Â¿O deseas agregar validaciones adicionales como scoring de riesgo o segmentaciones por clÃºsteres?


A continuaciÃ³n, te presento una propuesta de proyecto en Visual Studio Code para implementar un modelo de pricing actuarial para seguros de automÃ³viles utilizando Modelos Lineales Generalizados (GLM). El proyecto se divide en tres scripts de Python, tal como lo solicitaste.
Estructura del Proyecto
Se sugiere la siguiente estructura de carpetas y archivos dentro de tu proyecto en Visual Studio Code:
/pricing_automoviles
â”œâ”€â”€ /data
â”‚   â””â”€â”€ (aquÃ­ se guardarÃ¡ la base de datos ficticia)
â”œâ”€â”€ /src
â”‚   â”œâ”€â”€ 1_generar_datos_ficticios.py
â”‚   â”œâ”€â”€ 2_modelacion_glm.py
â”‚   â””â”€â”€ 3_cotizador.py
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

1. Script para generar una base de siniestros ficticia (1_generar_datos_ficticios.py)
Este script utiliza la librerÃ­a pandas para la manipulaciÃ³n de datos y numpy para la generaciÃ³n de valores aleatorios. Se generarÃ¡n datos que simulen el comportamiento de una cartera de seguros de automÃ³viles.
# 1_generar_datos_ficticios.py

import pandas as pd
import numpy as np
from datetime import datetime, timedelta

def generar_datos_ficticios(num_registros=10000):
    """
    Genera una base de datos ficticia de siniestros de automÃ³viles para pricing.

    Args:
        num_registros (int): NÃºmero de registros a generar.

    Returns:
        pd.DataFrame: DataFrame con los datos generados.
    """

    # --- Variables de las pÃ³lizas ---
    ids_poliza = [f'POL-{i+1:05d}' for i in range(num_registros)]
    fechas_emision = pd.to_datetime('2023-01-01') + pd.to_timedelta(np.random.randint(0, 365, num_registros), unit='D')
    dias_cobertura = np.random.randint(1, 365, num_registros)
    fechas_vencimiento = fechas_emision + pd.to_timedelta(dias_cobertura, unit='D')
    exposicion = dias_cobertura / 365.0

    # --- CaracterÃ­sticas del Conductor ---
    genero = np.random.choice(['Hombre', 'Mujer', 'Otro'], num_registros, p=[0.55, 0.44, 0.01])
    edad = np.random.randint(18, 75, num_registros)
    estado_civil = np.random.choice(['Soltero', 'Casado', 'Divorciado', 'Viudo'], num_registros, p=[0.45, 0.45, 0.05, 0.05])
    
    # SimulaciÃ³n: jÃ³venes solteros tienen mÃ¡s riesgo
    riesgo_edad_genero_civil = np.ones(num_registros)
    riesgo_edad_genero_civil[(edad < 25) & (genero == 'Hombre') & (estado_civil == 'Soltero')] = 1.5
    riesgo_edad_genero_civil[(edad < 25) & (genero == 'Mujer') & (estado_civil == 'Soltero')] = 1.3
    
    # --- CaracterÃ­sticas del VehÃ­culo ---
    marca = np.random.choice(['Toyota', 'Nissan', 'Ford', 'Chevrolet', 'BMW', 'Mercedes-Benz'], num_registros)
    modelo_anio = np.random.randint(2005, 2024, num_registros)
    cilindraje = np.random.choice([1.0, 1.2, 1.6, 2.0, 2.5, 3.0], num_registros, p=[0.1, 0.2, 0.3, 0.2, 0.1, 0.1])
    peso_kg = np.random.uniform(900, 2500, num_registros)
    puestos = np.random.choice([2, 4, 5, 7], num_registros, p=[0.05, 0.15, 0.7, 0.1])
    color = np.random.choice(['Blanco', 'Negro', 'Gris', 'Rojo', 'Azul'], num_registros)
    suma_asegurada = np.random.uniform(15000000, 250000000, num_registros)
    
    # SimulaciÃ³n: modelos mÃ¡s nuevos y de alta gama tienen mayor suma asegurada
    suma_asegurada[modelo_anio > 2020] *= 1.2
    suma_asegurada[marca.isin(['BMW', 'Mercedes-Benz'])] *= 1.5

    # --- GeneraciÃ³n de Siniestros (probabilidad) ---
    # La probabilidad de siniestro depende de las caracterÃ­sticas
    prob_base_siniestro = 0.05  # Probabilidad anual base
    prob_siniestro = prob_base_siniestro * exposicion * riesgo_edad_genero_civil
    
    # Ajuste de probabilidad por otras variables
    prob_siniestro[cilindraje > 2.0] *= 1.2
    prob_siniestro[puestos == 2] *= 1.1
    
    # Evento de siniestro
    siniestro = np.random.binomial(n=1, p=prob_siniestro, size=num_registros)
    
    # --- GeneraciÃ³n de la Severidad (monto del siniestro) ---
    tipo_dano = np.random.choice(['Perdida Parcial', 'Perdida Total', 'Robo'], num_registros, p=[0.75, 0.15, 0.10])
    
    monto_siniestro = np.zeros(num_registros)
    monto_siniestro[siniestro == 1] = np.random.lognormal(mean=np.log(2000000), sigma=1.0, size=np.sum(siniestro))
    
    # Ajuste de severidad por tipo de daÃ±o y suma asegurada
    idx_parcial = np.where((siniestro == 1) & (tipo_dano == 'Perdida Parcial'))
    monto_siniestro[idx_parcial] = np.random.uniform(500000, 0.5 * suma_asegurada[idx_parcial], len(idx_parcial[0]))
    
    idx_total = np.where((siniestro == 1) & (tipo_dano == 'Perdida Total'))
    monto_siniestro[idx_total] = np.random.uniform(0.7 * suma_asegurada[idx_total], 0.9 * suma_asegurada[idx_total], len(idx_total[0]))
    
    idx_robo = np.where((siniestro == 1) & (tipo_dano == 'Robo'))
    monto_siniestro[idx_robo] = np.random.uniform(0.9 * suma_asegurada[idx_robo], 1.0 * suma_asegurada[idx_robo], len(idx_robo[0]))
    
    # --- CreaciÃ³n del DataFrame ---
    df = pd.DataFrame({
        'id_poliza': ids_poliza,
        'fecha_emision': fechas_emision,
        'fecha_vencimiento': fechas_vencimiento,
        'exposicion': exposicion,
        'genero': genero,
        'edad': edad,
        'estado_civil': estado_civil,
        'marca': marca,
        'modelo_anio': modelo_anio,
        'cilindraje': cilindraje,
        'peso_kg': peso_kg,
        'puestos': puestos,
        'color': color,
        'suma_asegurada': suma_asegurada,
        'siniestro': siniestro,
        'tipo_dano_siniestro': np.where(siniestro == 1, tipo_dano, 'Sin Siniestro'),
        'monto_siniestro': monto_siniestro,
        'costo_anual_promedio': monto_siniestro / exposicion  # Severidad anualizada
    })
    
    return df

if __name__ == '__main__':
    # Genera la base de datos y la guarda en un archivo CSV
    df_siniestros = generar_datos_ficticios(num_registros=50000)
    df_siniestros.to_csv('data/siniestros_ficticios.csv', index=False)
    print("Base de datos ficticia generada y guardada en 'data/siniestros_ficticios.csv'")
    print(df_siniestros.head())
    print("\nInformaciÃ³n del DataFrame:")
    print(df_siniestros.info())


2. Script para la modelaciÃ³n GLM (2_modelacion_glm.py)
Este script utiliza la librerÃ­a statsmodels para los GLM, pandas para la manipulaciÃ³n de datos y matplotlib y seaborn para la visualizaciÃ³n. Se seguirÃ¡n los pasos tÃ­picos de un anÃ¡lisis actuarial:
 * Carga y preprocesamiento de datos.
 * ModelaciÃ³n de la Frecuencia (probabilidad): Se utilizarÃ¡ un GLM con una distribuciÃ³n Poisson y la funciÃ³n link logarÃ­tmica.
 * ModelaciÃ³n de la Severidad: Se utilizarÃ¡ un GLM con una distribuciÃ³n Gamma y la funciÃ³n link logarÃ­tmica.
 * CÃ¡lculo de la Prima de Riesgo Pura: Se multiplica la frecuencia esperada por la severidad esperada.
 * AnÃ¡lisis de resultados y grÃ¡ficos.
<!-- end list -->
# 2_modelacion_glm.py

import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
from patsy import dmatrices

# Cargar la base de datos ficticia
try:
    df = pd.read_csv('data/siniestros_ficticios.csv')
    print("Base de datos cargada exitosamente.")
except FileNotFoundError:
    print("Error: El archivo 'siniestros_ficticios.csv' no fue encontrado. Ejecute '1_generar_datos_ficticios.py' primero.")
    exit()

# --- 1. Preprocesamiento de datos para la modelaciÃ³n ---
# Convertir variables categÃ³ricas a tipo 'category'
categorical_cols = ['genero', 'estado_civil', 'marca', 'color', 'puestos']
for col in categorical_cols:
    df[col] = df[col].astype('category')

# --- 2. ModelaciÃ³n de la Frecuencia (Probabilidad de Siniestro) ---
print("\n--- Modelando la Frecuencia (GLM con Poisson) ---")
# La variable dependiente es el nÃºmero de siniestros. La variable 'exposicion' se utiliza como offset.
formula_frecuencia = 'siniestro ~ C(genero) + C(estado_civil) + edad + np.log(modelo_anio) + np.log(cilindraje) + np.log(peso_kg) + C(marca)'

# Dummies y matrices para el GLM
y_freq, X_freq = dmatrices(formula_frecuencia, data=df, return_type='dataframe')

# Modelo GLM de Frecuencia
# Familia: Poisson, Link: log
# El offset es el logaritmo natural de la exposiciÃ³n para modelar la tasa de siniestros
model_frecuencia = sm.GLM(y_freq, X_freq,
                          family=sm.families.Poisson(),
                          exposure=df['exposicion'])
result_frecuencia = model_frecuencia.fit()

print(result_frecuencia.summary())

# GrÃ¡fico de diagnÃ³stico: PredicciÃ³n vs. Real para la frecuencia
df['frecuencia_predicha'] = result_frecuencia.predict(X_freq)
plt.figure(figsize=(12, 6))
sns.histplot(df[df['siniestro'] == 1]['frecuencia_predicha'], label='Siniestros reales', color='red', kde=True)
sns.histplot(df['frecuencia_predicha'], label='Todas las pÃ³lizas', color='blue', alpha=0.5, kde=True)
plt.title('DistribuciÃ³n de Frecuencia Predicha vs Real')
plt.xlabel('Frecuencia Anual Esperada (lambda)')
plt.legend()
plt.show()

# --- 3. ModelaciÃ³n de la Severidad (Monto Promedio de Siniestro) ---
# Se modela solo con los registros que tuvieron siniestro
df_siniestrados = df[df['siniestro'] == 1].copy()
print(f"\n--- Modelando la Severidad (GLM con Gamma) - {len(df_siniestrados)} registros con siniestro ---")

# La variable dependiente es el 'costo_anual_promedio' (severidad)
formula_severidad = 'costo_anual_promedio ~ C(genero) + edad + np.log(modelo_anio) + np.log(cilindraje) + C(marca) + np.log(suma_asegurada)'

# Dummies y matrices para el GLM
y_sev, X_sev = dmatrices(formula_severidad, data=df_siniestrados, return_type='dataframe')

# Modelo GLM de Severidad
# Familia: Gamma, Link: log
model_severidad = sm.GLM(y_sev, X_sev, family=sm.families.Gamma(link=sm.families.links.log()))
result_severidad = model_severidad.fit()

print(result_severidad.summary())

# GrÃ¡fico de diagnÃ³stico: PredicciÃ³n vs. Real para la severidad
df_siniestrados['severidad_predicha'] = result_severidad.predict(X_sev)
plt.figure(figsize=(12, 6))
sns.scatterplot(x=df_siniestrados['costo_anual_promedio'], y=df_siniestrados['severidad_predicha'], alpha=0.5)
plt.plot([0, df_siniestrados['costo_anual_promedio'].max()], [0, df_siniestrados['costo_anual_promedio'].max()], 'r--')
plt.title('Severidad Predicha vs. Severidad Real')
plt.xlabel('Severidad Real Anual')
plt.ylabel('Severidad Predicha Anual')
plt.show()

# --- 4. CÃ¡lculo de la Prima de Riesgo Pura (Frecuencia * Severidad) ---
# Se aplica a toda la base de datos
df['severidad_predicha_total'] = result_severidad.predict(dmatrices(formula_severidad, data=df, return_type='dataframe')[1])

# Prima de Riesgo Pura = Frecuencia Esperada * Severidad Esperada
df['prima_riesgo_pura'] = df['frecuencia_predicha'] * df['severidad_predicha_total']

print("\n--- Resultados de la Prima de Riesgo Pura ---")
print(df[['frecuencia_predicha', 'severidad_predicha_total', 'prima_riesgo_pura']].describe())

# Ejemplo de la prima para un registro
print("\nEjemplo de la prima de riesgo pura para las primeras 5 pÃ³lizas:")
print(df[['id_poliza', 'exposicion', 'frecuencia_predicha', 'severidad_predicha_total', 'prima_riesgo_pura']].head())


3. Script tipo cotizador (3_cotizador.py)
Este script implementa una funciÃ³n que toma las caracterÃ­sticas de un cliente y su vehÃ­culo, utiliza los modelos GLM previamente entrenados para calcular la frecuencia y la severidad, y finalmente devuelve la prima de riesgo pura.
# 3_cotizador.py

import pandas as pd
import numpy as np
import statsmodels.api as sm
from patsy import dmatrices
import pickle
import os

def cargar_modelos(path_frecuencia='models/model_frecuencia.pkl', path_severidad='models/model_severidad.pkl'):
    """
    Carga los modelos entrenados desde archivos .pkl.
    """
    if not os.path.exists(path_frecuencia) or not os.path.exists(path_severidad):
        print("Error: Los modelos entrenados no se encontraron.")
        print("AsegÃºrate de que '2_modelacion_glm.py' haya sido ejecutado y guardado los modelos.")
        return None, None
    
    with open(path_frecuencia, 'rb') as f:
        model_frecuencia = pickle.load(f)
    with open(path_severidad, 'rb') as f:
        model_severidad = pickle.load(f)
    
    return model_frecuencia, model_severidad

def guardar_modelos(model_frecuencia, model_severidad, path='models'):
    """
    Guarda los modelos entrenados en la carpeta 'models'.
    """
    if not os.path.exists(path):
        os.makedirs(path)
    with open(f'{path}/model_frecuencia.pkl', 'wb') as f:
        pickle.dump(model_frecuencia, f)
    with open(f'{path}/model_severidad.pkl', 'wb') as f:
        pickle.dump(model_severidad, f)
    print(f"Modelos guardados en '{path}'.")


def cotizar_prima_riesgo(datos_cliente, model_frecuencia, model_severidad):
    """
    Calcula la prima de riesgo pura para un cliente dado sus datos.

    Args:
        datos_cliente (dict): Diccionario con las caracterÃ­sticas del cliente y vehÃ­culo.
        model_frecuencia (sm.GLM.fit): Modelo GLM para la frecuencia.
        model_severidad (sm.GLM.fit): Modelo GLM para la severidad.

    Returns:
        float: Prima de riesgo pura calculada.
    """

    # Crear un DataFrame con un solo registro para la cotizaciÃ³n
    df_cotizar = pd.DataFrame([datos_cliente])
    df_cotizar['exposicion'] = 1.0  # Se asume una exposiciÃ³n de 1 aÃ±o para la cotizaciÃ³n

    # --- 1. Predecir Frecuencia ---
    formula_frecuencia = 'siniestro ~ C(genero) + C(estado_civil) + edad + np.log(modelo_anio) + np.log(cilindraje) + np.log(peso_kg) + C(marca)'
    # Creamos las matrices de diseÃ±o usando los mismos nombres de variables del modelo
    # Esto es crucial para que la predicciÃ³n funcione correctamente
    df_cotizar['siniestro'] = 0 # Variable dummy necesaria para dmatrices
    _, X_freq_cotizar = dmatrices(formula_frecuencia, data=df_cotizar, return_type='dataframe')
    frecuencia_predicha = model_frecuencia.predict(X_freq_cotizar)[0]

    # --- 2. Predecir Severidad ---
    formula_severidad = 'costo_anual_promedio ~ C(genero) + edad + np.log(modelo_anio) + np.log(cilindraje) + C(marca) + np.log(suma_asegurada)'
    # Creamos las matrices de diseÃ±o para la severidad
    df_cotizar['costo_anual_promedio'] = 1 # Variable dummy necesaria para dmatrices
    _, X_sev_cotizar = dmatrices(formula_severidad, data=df_cotizar, return_type='dataframe')
    severidad_predicha = model_severidad.predict(X_sev_cotizar)[0]
    
    # --- 3. Calcular Prima de Riesgo Pura ---
    prima_riesgo_pura = frecuencia_predicha * severidad_predicha

    return prima_riesgo_pura, frecuencia_predicha, severidad_predicha

if __name__ == '__main__':
    # Antes de ejecutar este script, es necesario ejecutar '2_modelacion_glm.py'
    # para entrenar y guardar los modelos.
    
    # Cargar los modelos entrenados
    model_frecuencia, model_severidad = cargar_modelos()
    
    if model_frecuencia and model_severidad:
        print("\n--- Cotizador de Prima de Riesgo Pura ---")
        
        # Ejemplo de cotizaciÃ³n con datos de un cliente
        datos_nuevo_cliente = {
            'genero': 'Mujer',
            'estado_civil': 'Casado',
            'edad': 45,
            'marca': 'Toyota',
            'modelo_anio': 2022,
            'cilindraje': 1.6,
            'peso_kg': 1400.0,
            'color': 'Blanco',
            'puestos': 5,
            'suma_asegurada': 60000000.0,
        }
        
        prima, frec, sev = cotizar_prima_riesgo(datos_nuevo_cliente, model_frecuencia, model_severidad)
        
        print("\n--- Datos del Cliente a Cotizar ---")
        for key, value in datos_nuevo_cliente.items():
            print(f"{key}: {value}")
            
        print("\n--- Resultados de la CotizaciÃ³n ---")
        print(f"Frecuencia Anual Esperada: {frec:.4f}")
        print(f"Severidad Esperada del Siniestro: ${sev:,.2f}")
        print(f"PRIMA DE RIESGO PURA Anual Estimada: ${prima:,.2f}")

        # Ejemplo de otro cliente mÃ¡s riesgoso
        print("\n--- Ejemplo de un cliente mÃ¡s riesgoso (joven, soltero) ---")
        datos_cliente_riesgoso = {
            'genero': 'Hombre',
            'estado_civil': 'Soltero',
            'edad': 22,
            'marca': 'Ford',
            'modelo_anio': 2018,
            'cilindraje': 2.0,
            'peso_kg': 1600.0,
            'color': 'Rojo',
            'puestos': 5,
            'suma_asegurada': 45000000.0,
        }
        
        prima_riesgo, frec_riesgo, sev_riesgo = cotizar_prima_riesgo(datos_cliente_riesgoso, model_frecuencia, model_severidad)
        
        print("\n--- Datos del Cliente a Cotizar ---")
        for key, value in datos_cliente_riesgoso.items():
            print(f"{key}: {value}")

        print("\n--- Resultados de la CotizaciÃ³n ---")
        print(f"Frecuencia Anual Esperada: {frec_riesgo:.4f}")
        print(f"Severidad Esperada del Siniestro: ${sev_riesgo:,.2f}")
        print(f"PRIMA DE RIESGO PURA Anual Estimada: ${prima_riesgo:,.2f}")


Instrucciones para la EjecuciÃ³n del Proyecto en Visual Studio Code
 * Crea la estructura de carpetas mencionada anteriormente (/pricing_automoviles, /data, /src, /models).
 * Instala las librerÃ­as necesarias: Abre la terminal en Visual Studio Code y ejecuta:
   pip install pandas numpy statsmodels patsy matplotlib seaborn scikit-learn

   (Se incluye scikit-learn en caso de que quieras explorar otros modelos, aunque los GLM se manejan con statsmodels).
 * Ejecuta el primer script: Abre 1_generar_datos_ficticios.py en el editor y presiona Ctrl + F5 o haz clic en el botÃ³n de "Run" en la esquina superior derecha. Esto crearÃ¡ el archivo siniestros_ficticios.csv en la carpeta /data.
 * Ejecuta el segundo script: Abre 2_modelacion_glm.py y ejecÃºtalo. Este script cargarÃ¡ la base de datos, entrenarÃ¡ los modelos de frecuencia y severidad, mostrarÃ¡ los resÃºmenes estadÃ­sticos de los modelos y los grÃ¡ficos de diagnÃ³stico. Importante: Este script tambiÃ©n guarda los modelos entrenados en la carpeta /models para que puedan ser usados por el cotizador.
 * Ejecuta el tercer script: Abre 3_cotizador.py y ejecÃºtalo. Este script cargarÃ¡ los modelos guardados y te mostrarÃ¡ la cotizaciÃ³n de ejemplo para los clientes predefinidos. Puedes modificar el diccionario datos_nuevo_cliente para probar diferentes perfiles.
Este proyecto te proporciona una base sÃ³lida para entender y aplicar los conceptos actuariales de pricing con GLM en un entorno prÃ¡ctico y reproducible.

