
Gracias por el contexto. Te corrijo el c√≥digo completo con lo siguiente:

‚∏ª

‚úÖ Mejoras aplicadas:
	1.	Fecha de corte fija: 30 de junio de 2025 (fecha_corte = datetime(2025, 6, 30)).
	2.	Las fechas de reporte y de cierre no pueden superar esa fecha.
	3.	La fecha de cierre solo se genera si el resultado es 'CORROBORADO' o 'NO CORROBORADO'.
	4.	Corregido el uso de fecha_reporte para que sea una fecha real tipo datetime, y luego formateada en sucio.

‚∏ª

üß† C√≥digo corregido completo (solo la parte de generaci√≥n de casos)

import pandas as pd
import random
from faker import Faker
import os
from datetime import datetime, timedelta

fake = Faker('es_CO')

# Crear carpeta si no existe
os.makedirs("datos_simulados", exist_ok=True)

# ---------- PARTE 1: Crear base de identificaciones ----------
# (se mantiene igual...)

# ---------- PARTE 2: Crear base de casos ----------
n = 10000
case_types = ['ALERTA', 'DILEMA', 'FALTA DE TERCEROS', 'DENUNCIA']
resultados = ['CORROBORADO', 'NO CORROBORADO', 'EN INVESTIGACI√ìN']
cargo = ['PROFESIONAL', 'GERENTE', 'COORDINADOR', 'CLIENTE', 'CONTRATISTA','VICEPRESIDENTE','TECNICO']
roles = ['DENUNCIANTE', 'IMPLICADO', '']

# Definir fecha de corte
fecha_corte = datetime(2025, 6, 30)

# Funci√≥n para formatear fechas "sucias"
def fecha_sucia(date_obj):
    formatos = ['%Y-%m-%d', '%d/%m/%Y', '%m-%d-%Y', '%d-%b-%Y', '%Y/%m/%d']
    return date_obj.strftime(random.choice(formatos))

# Funci√≥n para generar resumen coherente
def generar_resumen_hechos(nombre, tipo_caso):
    hechos = {
        'ALERTA': [
            f"Se recibi√≥ una alerta an√≥nima en la que se reporta una posible irregularidad cometida por {nombre} relacionada con procedimientos de contrataci√≥n.",
            f"Durante un control rutinario, se identific√≥ una alerta interna que involucra a {nombre} por presunto incumplimiento de pol√≠ticas de seguridad.",
            f"El sistema de auditor√≠a autom√°tica gener√≥ una alerta por accesos inusuales realizados por {nombre} en horarios no laborables."
        ],
        'DILEMA': [
            f"{nombre} consult√≥ al √°rea de √©tica sobre un posible conflicto de inter√©s al participar en un proceso donde est√° involucrado un familiar cercano.",
            f"Se report√≥ un dilema √©tico por parte de {nombre} al recibir obsequios de un proveedor con el que actualmente negocia condiciones contractuales.",
            f"{nombre} expres√≥ dudas sobre su participaci√≥n en decisiones que pueden generar beneficios personales indirectos."
        ],
        'FALTA DE TERCEROS': [
            f"{nombre} report√≥ que un contratista incurri√≥ en comportamientos inadecuados con otros empleados durante una reuni√≥n.",
            f"Seg√∫n {nombre}, un proveedor incurri√≥ en pr√°cticas que contravienen el c√≥digo de √©tica durante la ejecuci√≥n de un proyecto.",
            f"Se recibi√≥ reporte de {nombre} donde manifiesta que un cliente realiz√≥ insinuaciones indebidas hacia su equipo de trabajo."
        ],
        'DENUNCIA': [
            f"{nombre} present√≥ una denuncia formal contra un compa√±ero por acoso laboral reiterado desde el mes de abril.",
            f"Se recibi√≥ denuncia de {nombre} en la que se indica que su jefe inmediato ha manipulado resultados para favorecer decisiones personales.",
            f"{nombre} interpuso una denuncia por actos de corrupci√≥n en el proceso de selecci√≥n de contratistas, con evidencia documental."
        ]
    }
    return random.choice(hechos[tipo_caso])

# Generar datos
data_casos = []
for i in range(n):
    id_random = random.choice(ids)
    nombre = df_ident[df_ident['NUMERO_IDENTIFICACION_COND'] == id_random]['NOMBRE_COMPLETO_COND'].values[0]
    tipo_caso = random.choice(case_types)
    resultado = random.choice(resultados)

    # Generar fecha de reporte (m√°ximo hasta la fecha de corte)
    fecha_inicio = fecha_corte - timedelta(days=730)  # Hasta 2 a√±os antes
    fecha_reporte_dt = fake.date_between_dates(date_start=fecha_inicio, date_end=fecha_corte)
    fecha_reporte_str = fecha_sucia(fecha_reporte_dt)

    # Generar fecha de cierre solo si est√° cerrado
    if resultado in ['CORROBORADO', 'NO CORROBORADO']:
        cierre_min = fecha_reporte_dt + timedelta(days=5)
        cierre_max = min(fecha_corte, fecha_reporte_dt + timedelta(days=90))
        if cierre_min >= cierre_max:
            fecha_cierre_str = ''
        else:
            fecha_cierre_dt = fake.date_between_dates(date_start=cierre_min, date_end=cierre_max)
            fecha_cierre_str = fecha_sucia(fecha_cierre_dt)
    else:
        fecha_cierre_str = ''

    fila = [
        f"{random.choice(['COMPA√ëIA_AA', 'COMPA√ëIA_BB', 'COMPA√ëIA_CC', 'COMPA√ëIA_DD'])}-{random.randint(2018, 2024)}-{random.randint(1, 12)}-{random.randint(20000, 29999)}",
        random.choice(roles),
        tipo_caso,
        nombre,
        id_random,
        random.choice(cargo),
        resultado,
        generar_resumen_hechos(nombre, tipo_caso),
        fecha_reporte_str,
        fecha_cierre_str
    ]
    data_casos.append(fila)

# Crear DataFrame
df_casos = pd.DataFrame(data_casos, columns=[
    'CASE_NUMBER', 'ROL', 'CASE_TYPE', 'NOMBRE_COMPLETO_COND',
    'NUMERO_IDENTIFICACION_COND', 'CARGO', 'RESULTADO_VERIFICACION',
    'RESUMEN_DE_LOS_HECHOS', 'FECHA_REPORTE', 'FECHA_CIERRE'
])

# Introducir duplicados y errores tipogr√°ficos (opcional)
df_casos = pd.concat([df_casos, df_casos.sample(100, random_state=1)], ignore_index=True)
errores = df_casos.sample(frac=0.05, random_state=2).index
df_casos.loc[errores, 'NOMBRE_COMPLETO_COND'] = df_casos.loc[errores, 'NOMBRE_COMPLETO_COND'].apply(lambda x: x.replace('a', '@', 1))

# Guardar archivo
df_casos.to_csv("datos_simulados/simulacion_datos_excel.csv", index=False, encoding='utf-8-sig')


‚∏ª

‚úÖ Resultado
	‚Ä¢	No hay fechas de reporte ni cierre posteriores al 30 de junio de 2025.
	‚Ä¢	FECHA_CIERRE s√≥lo est√° llena si el caso est√° cerrado.
	‚Ä¢	El campo respeta formatos ‚Äúsucios‚Äù variados.

¬øQuieres tambi√©n que agregue una validaci√≥n o bandera (ESTADO) con los valores "CERRADO" o "EN PROCESO" para facilitar el an√°lisis posterior?



Perfecto. Para agregar una columna de FECHA_CIERRE solo cuando el resultado del caso sea 'CORROBORADO' o 'NO CORROBORADO', y dejarla vac√≠a ('') cuando est√© 'EN INVESTIGACI√ìN', simplemente debes modificar el bucle donde generas cada fila de caso.

Aqu√≠ te muestro exactamente c√≥mo ajustarlo:

‚∏ª

‚úÖ Paso 1: A√±adir l√≥gica para FECHA_CIERRE

Justo antes de construir la fila, agrega esto:

resultado = random.choice(resultados)
fecha_reporte = fecha_sucia()

# Si el caso est√° cerrado, generar fecha de cierre posterior a la fecha de reporte
if resultado in ['CORROBORADO', 'NO CORROBORADO']:
    # Convertir fecha_reporte a datetime para calcular cierre
    try:
        fecha_reporte_dt = pd.to_datetime(fecha_reporte, dayfirst=True, errors='coerce')
        if pd.isna(fecha_reporte_dt):
            fecha_cierre = ''
        else:
            fecha_cierre_dt = fecha_reporte_dt + pd.to_timedelta(random.randint(5, 90), unit='d')
            formatos = ['%Y-%m-%d', '%d/%m/%Y', '%m-%d-%Y', '%d-%b-%Y', '%Y/%m/%d']
            fecha_cierre = fecha_cierre_dt.strftime(random.choice(formatos))
    except:
        fecha_cierre = ''
else:
    fecha_cierre = ''


‚∏ª

‚úÖ Paso 2: Incluir fecha_cierre en tu fila

Agrega fecha_cierre al final de la fila:

fila = [
    f"{random.choice(['COMPA√ëIA_AA', 'COMPA√ëIA_BB', 'COMPA√ëIA_CC', 'COMPA√ëIA_DD'])}-{random.randint(2018, 2024)}-{random.randint(1, 12)}-{random.randint(20000, 29999)}",
    random.choice(roles),
    tipo_caso,
    nombre,
    id_random,
    random.choice(cargo),
    resultado,
    generar_resumen_hechos(nombre, tipo_caso),
    fecha_reporte,
    fecha_cierre
]


‚∏ª

‚úÖ Paso 3: Agrega el nombre de la nueva columna

Actualiza esta l√≠nea:

df_casos = pd.DataFrame(data_casos, columns=[
    'CASE_NUMBER', 'ROL', 'CASE_TYPE', 'NOMBRE_COMPLETO_COND',
    'NUMERO_IDENTIFICACION_COND', 'CARGO', 'RESULTADO_VERIFICACION',
    'RESUMEN_DE_LOS_HECHOS', 'FECHA_REPORTE', 'FECHA_CIERRE'
])


‚∏ª

üìå Resultado
	‚Ä¢	Tendr√°s una columna adicional FECHA_CIERRE.
	‚Ä¢	En los casos cerrados (CORROBORADO, NO CORROBORADO) tendr√° una fecha posterior a la de reporte.
	‚Ä¢	En los casos abiertos (EN INVESTIGACI√ìN), estar√° vac√≠a.

‚∏ª

¬øDeseas que la diferencia entre fecha de reporte y de cierre se limite a cierto rango espec√≠fico (ej. m√≠nimo 15 d√≠as y m√°ximo 60)? ¬øO lo dejamos como est√°?

para los casos que son corroborados y no corroborados, se condiseran casos cerrados, por lo que debo agregar un campo de fecha de cierre para estos casos y en donde el resultado diga "en investigaci√≥n" esta fecha debe estar en blanco

import pandas as pd
import random
from faker import Faker
import os

fake = Faker('es_CO')

# Crear carpeta si no existe
os.makedirs("datos_simulados", exist_ok=True)

# ---------- PARTE 1: Crear base de identificaciones ----------
num_personas = 2000
ids = set()
while len(ids) < num_personas:
    ids.add(fake.random_int(min=10000, max=99999))
ids = list(ids)

ciudades_colombia = [
    'Bogot√°', 'Barrancabermeja', 'Barranquilla', 'Cartagena', 'C√∫cuta',
    'Bucaramanga', 'Orito', 'Manizales', 'Villavicencio',
    'Neiva', 'Puerto Gait√°n','Acac√≠as','Tauramena','Yopal','Saravena','Apiay','Cali'
]

# Crear datos de identificaci√≥n
data_ident = []
for id_num in ids:
    fila = [
        id_num,
        fake.date_of_birth(minimum_age=18, maximum_age=70).strftime('%Y-%m-%d'),
        random.choice(ciudades_colombia),
        fake.name()
    ]
    data_ident.append(fila)

df_ident = pd.DataFrame(data_ident, columns=[
    'NUMERO_IDENTIFICACION_COND', 'FECHA_NACIMIENTO', 'CIUDAD_TRABAJO', 'NOMBRE_COMPLETO_COND'
])
df_ident.to_csv("datos_simulados/base_identificaciones.csv", index=False, encoding='utf-8-sig')

# ---------- PARTE 2: Crear base de casos ----------
n = 10000  # N√∫mero de casos a simular
case_types = ['ALERTA', 'DILEMA', 'FALTA DE TERCEROS', 'DENUNCIA']
resultados = ['CORROBORADO', 'NO CORROBORADO', 'EN INVESTIGACI√ìN']
cargo = ['PROFESIONAL', 'GERENTE', 'COORDINADOR', 'CLIENTE', 'CONTRATISTA','VICEPRESIDENTE','TECNICO']
roles = ['DENUNCIANTE', 'IMPLICADO', '']

def fecha_sucia():
    date = fake.date_between(start_date='-2y', end_date='today')
    formatos = ['%Y-%m-%d', '%d/%m/%Y', '%m-%d-%Y', '%d-%b-%Y', '%Y/%m/%d']
    return date.strftime(random.choice(formatos))

# Generar datos de casos

def generar_resumen_hechos(nombre, tipo_caso):
    hechos = {
        'ALERTA': [
            f"Se recibi√≥ una alerta an√≥nima en la que se reporta una posible irregularidad cometida por {nombre} relacionada con procedimientos de contrataci√≥n.",
            f"Durante un control rutinario, se identific√≥ una alerta interna que involucra a {nombre} por presunto incumplimiento de pol√≠ticas de seguridad.",
            f"El sistema de auditor√≠a autom√°tica gener√≥ una alerta por accesos inusuales realizados por {nombre} en horarios no laborables."
        ],
        'DILEMA': [
            f"{nombre} consult√≥ al √°rea de √©tica sobre un posible conflicto de inter√©s al participar en un proceso donde est√° involucrado un familiar cercano.",
            f"Se report√≥ un dilema √©tico por parte de {nombre} al recibir obsequios de un proveedor con el que actualmente negocia condiciones contractuales.",
            f"{nombre} expres√≥ dudas sobre su participaci√≥n en decisiones que pueden generar beneficios personales indirectos."
        ],
        'FALTA DE TERCEROS': [
            f"{nombre} report√≥ que un contratista incurri√≥ en comportamientos inadecuados con otros empleados durante una reuni√≥n.",
            f"Seg√∫n {nombre}, un proveedor incurri√≥ en pr√°cticas que contravienen el c√≥digo de √©tica durante la ejecuci√≥n de un proyecto.",
            f"Se recibi√≥ reporte de {nombre} donde manifiesta que un cliente realiz√≥ insinuaciones indebidas hacia su equipo de trabajo."
        ],
        'DENUNCIA': [
            f"{nombre} present√≥ una denuncia formal contra un compa√±ero por acoso laboral reiterado desde el mes de abril.",
            f"Se recibi√≥ denuncia de {nombre} en la que se indica que su jefe inmediato ha manipulado resultados para favorecer decisiones personales.",
            f"{nombre} interpuso una denuncia por actos de corrupci√≥n en el proceso de selecci√≥n de contratistas, con evidencia documental."
        ]
    }
    return random.choice(hechos[tipo_caso])

data_casos = []
for i in range(n):
    id_random = random.choice(ids)
    nombre = df_ident[df_ident['NUMERO_IDENTIFICACION_COND'] == id_random]['NOMBRE_COMPLETO_COND'].values[0]
    tipo_caso = random.choice(case_types)

    fila = [
        f"{random.choice(['COMPA√ëIA_AA', 'COMPA√ëIA_BB', 'COMPA√ëIA_CC', 'COMPA√ëIA_DD'])}-{random.randint(2018, 2024)}-{random.randint(1, 12)}-{random.randint(20000, 29999)}",
        random.choice(roles),
        tipo_caso,
        nombre,
        id_random,
        random.choice(cargo),
        random.choice(resultados),
        generar_resumen_hechos(nombre, tipo_caso),
        fecha_sucia()
    ]
    data_casos.append(fila)

df_casos = pd.DataFrame(data_casos, columns=[
    'CASE_NUMBER', 'ROL', 'CASE_TYPE', 'NOMBRE_COMPLETO_COND',
    'NUMERO_IDENTIFICACION_COND', 'CARGO', 'RESULTADO_VERIFICACION',
    'RESUMEN_DE_LOS_HECHOS', 'FECHA_REPORTE'
])

# Introducir duplicados y errores tipogr√°ficos (opcional)
df_casos = pd.concat([df_casos, df_casos.sample(100, random_state=1)], ignore_index=True)
errores = df_casos.sample(frac=0.05, random_state=2).index
df_casos.loc[errores, 'NOMBRE_COMPLETO_COND'] = df_casos.loc[errores, 'NOMBRE_COMPLETO_COND'].apply(lambda x: x.replace('a', '@', 1))

# Guardar
df_casos.to_csv("datos_simulados/simulacion_datos_excel.csv", index=False, encoding='utf-8-sig')
