Para asegurar que el texto se maneje correctamente cuando llega al final de la página y respetar el margen inferior, debemos ajustar la lógica que maneja la inserción del texto y la creación de nuevas páginas.

Aquí tienes una versión corregida y detallada:

```python
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.lib import utils
from reportlab.pdfgen import canvas
import datetime
import re
from flask import Flask, send_file

app = Flask(__name__)

chat_history = [("User1", "Este es un mensaje muy largo que puede necesitar ser dividido en múltiples líneas en el PDF para asegurarse de que no se corta y se muestra correctamente." * 5)]

@app.route('/download')
def download_chat():
    global chat_history
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Definir márgenes
    margin_left = 50
    margin_right = 50
    margin_top = 50
    margin_bottom = 50
    max_width = width - margin_left - margin_right
    page_count = 1

    # Definir funciones para encabezado y pie de página
    def draw_header_footer(canvas, page_count):
        canvas.setFont("Helvetica", 12)
        canvas.drawString(margin_left, height - margin_top + 10, "Historia del Chat")
        canvas.drawString(width - margin_right - 100, height - margin_top + 10, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        canvas.setFont("Helvetica", 10)
        canvas.drawString(margin_left, margin_bottom - 30, f"Página {page_count}")

    # Iniciar la primera página
    draw_header_footer(c, page_count)
    y = height - margin_top - 20
    c.setFont("Helvetica", 12)
    
    def draw_text(text_object, text, max_width, canvas, page_count):
        lines = utils.simpleSplit(text, text_object._fontname, text_object._fontsize, max_width)
        for line in lines:
            if text_object.getY() < margin_bottom:
                canvas.drawText(text_object)
                canvas.showPage()
                page_count += 1
                draw_header_footer(canvas, page_count)
                text_object = canvas.beginText(margin_left, height - margin_top - 20)
                text_object.setFont("Helvetica", 12)
            text_object.textLine(line)
        return text_object, page_count

    text_object = c.beginText(margin_left, y)
    text_object.setFont("Helvetica", 12)

    def clean_html(text):
        clean = re.compile('<.*?>')
        return re.sub(clean, ' / ', text)

    for sender, message in chat_history:
        clean_message = clean_html(message).replace('\n', ' ')
        text = f"{sender}: {clean_message}"
        text_object, page_count = draw_text(text_object, text, max_width, c, page_count)
        text_object.moveCursor(0, 14)

    c.drawText(text_object)
    c.save()
    buffer.seek(0)
    return send_file(buffer, as_attachment=True, download_name="chat_history.pdf")

if __name__ == "__main__":
    app.run(debug=True)
```

### Cambios realizados:
1. **Reinicio de `text_object` al cambiar de página:** Ahora la función `draw_text` devuelve `text_object` y `page_count`, permitiendo actualizar estos valores en cada iteración.
2. **Márgenes:** Asegurarse de que el texto respete los márgenes definidos.

Con estas modificaciones, el texto debería manejarse correctamente al final de la página y respetar el margen inferior.

El error se debe a que el objeto `canvas.Canvas` de ReportLab no tiene el atributo `page`. Para solucionar esto, necesitamos mantener un contador de páginas manualmente.

Aquí tienes la versión corregida del código:

```python
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.lib import utils
from reportlab.pdfgen import canvas
import datetime
import re
from flask import Flask, send_file

app = Flask(__name__)

chat_history = [("User1", "Este es un mensaje muy largo que puede necesitar ser dividido en múltiples líneas en el PDF para asegurarse de que no se corta y se muestra correctamente." * 5)]

@app.route('/download')
def download_chat():
    global chat_history
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Definir márgenes
    margin_left = 50
    margin_right = 50
    margin_top = 50
    margin_bottom = 50
    max_width = width - margin_left - margin_right
    page_count = 1

    # Definir funciones para encabezado y pie de página
    def draw_header_footer(canvas, page_count):
        canvas.setFont("Helvetica", 12)
        canvas.drawString(margin_left, height - margin_top + 10, "Historia del Chat")
        canvas.drawString(width - margin_right - 100, height - margin_top + 10, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        canvas.setFont("Helvetica", 10)
        canvas.drawString(margin_left, margin_bottom - 30, f"Página {page_count}")

    # Iniciar la primera página
    draw_header_footer(c, page_count)
    y = height - margin_top - 20
    c.setFont("Helvetica", 12)
    
    def draw_text(text_object, text, max_width):
        nonlocal page_count
        lines = utils.simpleSplit(text, text_object._fontname, text_object._fontsize, max_width)
        for line in lines:
            if text_object.getY() < margin_bottom:
                c.drawText(text_object)
                c.showPage()
                page_count += 1
                draw_header_footer(c, page_count)
                text_object = c.beginText(margin_left, height - margin_top - 20)
                text_object.setFont("Helvetica", 12)
            text_object.textLine(line)
        return text_object

    text_object = c.beginText(margin_left, y)
    text_object.setFont("Helvetica", 12)

    def clean_html(text):
        clean = re.compile('<.*?>')
        return re.sub(clean, ' / ', text)

    for sender, message in chat_history:
        clean_message = clean_html(message).replace('\n', ' ')
        text = f"{sender}: {clean_message}"
        text_object = draw_text(text_object, text, max_width)
        text_object.moveCursor(0, 14)

    c.drawText(text_object)
    c.save()
    buffer.seek(0)
    return send_file(buffer, as_attachment=True, download_name="chat_history.pdf")

if __name__ == "__main__":
    app.run(debug=True)
```

### Cambios realizados:
1. **Contador de páginas:** Añadí una variable `page_count` para llevar el control manual del número de páginas.
2. **Encabezado y pie de página:** Ahora se pasa `page_count` a la función `draw_header_footer` para actualizar el número de página.

Con estos ajustes, deberías poder generar el PDF sin cortar el texto y con encabezados y pies de página correctamente numerados.

Para resolver el problema del texto cortado y añadir márgenes, pies de página y encabezados, puedes mejorar tu función de la siguiente manera:

1. **Márgenes:** Ajustar los márgenes del documento.
2. **Paginación:** Asegurarse de que el texto que no cabe en una página se continúe en la siguiente.
3. **Encabezado y pie de página:** Añadir encabezado y pie de página personalizados.

Aquí tienes una versión mejorada:

```python
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.lib import utils
from reportlab.pdfgen import canvas
import datetime
import re
from flask import send_file

@app.route('/download')
def download_chat():
    global chat_history
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Definir márgenes
    margin_left = 50
    margin_right = 50
    margin_top = 50
    margin_bottom = 50
    max_width = width - margin_left - margin_right

    # Definir funciones para encabezado y pie de página
    def draw_header_footer(canvas, doc):
        canvas.setFont("Helvetica", 12)
        canvas.drawString(margin_left, height - margin_top + 10, "Historia del Chat")
        canvas.drawString(width - margin_right - 100, height - margin_top + 10, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        canvas.setFont("Helvetica", 10)
        canvas.drawString(margin_left, margin_bottom - 30, f"Página {doc.page}")

    # Iniciar la primera página
    draw_header_footer(c, c)
    y = height - margin_top - 20
    c.setFont("Helvetica", 12)
    
    def draw_text(text_object, text, max_width):
        lines = utils.simpleSplit(text, text_object._fontname, text_object._fontsize, max_width)
        for line in lines:
            if text_object.getY() < margin_bottom:
                c.drawText(text_object)
                c.showPage()
                draw_header_footer(c, c)
                text_object = c.beginText(margin_left, height - margin_top - 20)
                text_object.setFont("Helvetica", 12)
            text_object.textLine(line)
        return text_object

    text_object = c.beginText(margin_left, y)
    text_object.setFont("Helvetica", 12)

    def clean_html(text):
        clean = re.compile('<.*?>')
        return re.sub(clean, ' / ', text)

    for sender, message in chat_history:
        clean_message = clean_html(message).replace('\n', ' ')
        text = f"{sender}: {clean_message}"
        text_object = draw_text(text_object, text, max_width)
        text_object.moveCursor(0, 14)

    c.drawText(text_object)
    c.save()
    buffer.seek(0)
    return send_file(buffer, as_attachment=True, download_name="chat_history.pdf")
```

### Desglose de la solución:
1. **Márgenes:** He definido márgenes ajustables (`margin_left`, `margin_right`, `margin_top`, `margin_bottom`) para controlar la posición del texto en la página.
2. **Paginación:** La función `draw_text` ahora verifica si el cursor está cerca del margen inferior y, si es así, crea una nueva página y continúa el texto.
3. **Encabezado y pie de página:** La función `draw_header_footer` añade un encabezado y un pie de página personalizados en cada página.

Con estas modificaciones, el PDF debería gestionar correctamente los textos largos y mantener un formato coherente y estilizado en todas las páginas.

@app.route('/download')
def download_chat():
    global chat_history
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    c.setFont("Helvetica", 12)
    c.drawString(200, height - 40, "Historia del Chat")
    c.drawString(200, height - 60, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    y = height - 100
    max_width = width - 60  # Reduce the width to avoid cutting off the text
    def draw_text(text_object, text, max_width):
        lines = utils.simpleSplit(text, text_object._fontname, text_object._fontsize, max_width)
        for line in lines:
            text_object.textLine(line)
    text_object = c.beginText(30, y)
    text_object.setFont("Helvetica", 12)
    def clean_html(text):
        clean = re.compile('<.*?>')
        return re.sub(clean, ' / ', text)
    for sender, message in chat_history:
        clean_message = clean_html(message).replace('\n', ' ')
        text = f"{sender}: {clean_message}"
        if text_object.getY() < 40:
            c.drawText(text_object)
            c.showPage()
            text_object = c.beginText(30, height - 40)
            text_object.setFont("Helvetica", 12)
        draw_text(text_object, text, max_width)
        text_object.moveCursor(0, 14)
    c.drawText(text_object)
    c.save()
    buffer.seek(0)
    return send_file(buffer, as_attachment=True, download_name="chat_history.pdf")


# Gráfico de percentiles
    plt.figure(figsize=(10, 6))
    sns.lineplot(x=np.arange(0, 101), y=percentiles)
    plt.title('Percentiles del % LRC')
    plt.xlabel('Percentiles')
    plt.ylabel('% LRC')
    plt.axhline(y=percentil_90,color='red')

\lrc_env\Lib\site-packages\scipy\stats\_distn_infrastructure.py", line 1096, in rvs  
    raise ValueError(message)
ValueError: Domain error in arguments. The `scale` parameter must be positive for all distributions, and many distributions have restrictions on shape parameters. Please see the `scipy.stats.triang` documentation for details.

Hola quiero hacer una aplicacion en python, pero tengo el siguiente codigo en R, ayudame con lo siguiente:
1. la idea es que desde la aplicación se pueda cargar el archivo excel llamado Riesgos.xlsx, solcite el número de expuestos y este valor por defecto tenga el valor 1, solicite el valor del presupuesto.
2. tambien debe solicitar como entrada el factor de riesgos (factor_riesgo), factor de gastos (factor_gastos), factor legal (factor_legal), estos factores deben ser porcentajes, pero al momento de utilizarlos deben estar sumados con el 100% es decir si ingresan %5 para el factor de riesgos, el factor_riesgo será 1.05.
3. La aplicación debe utilizar simulación montecarlo de una distribución triangular para determinar la suma asegurada o limite de responsabilidad a partir de un escenario pesimista, probable y optimista (tal como se hizo en R); entonces se debe solicitar tambien el numero de simulaciones (por defecto 10000) y tambien solicitar la semilla
4. quiero que la aplicación muestre los valores mas relevantes (valor esperado, mediana...etc), muestre la curva de percentiles indicando los valores de sumas aseguradas para cada percentil y que estos se muestren de manera dinamica.
5. Adicionalmente se hace un análisis de sensibilidad a partir de modificaciones de los tre factores de riesgo, gastos y legal, diseña una opcion en la que esta posibilidad se pueda visualizar en otra ventaja u hoja, yo hice un grafico en plotly para mostrar en 3d las variaciones de la suma asegurada a partir de las combinaciones de los factores.
6. Quiero que analices este codigo y lo reinterprtes en python, utiliza flask, y diferentes paginas html para que el diseño, resultados y formularios se vean de manera profesional y util.
7. al final poder descargar un pdf con los resultados mas importantes, curva de percentiles, numero de simulaciones hechas, semilla utilizada, un reporte ejecutivo.

if(!require(triangle)) install.packages("triangle", dependencies=TRUE)
if(!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(triangle)
library(ggplot2)
library('xlsx')
library('writexl')
library("readxl")
library(dplyr)
# Establecer la semilla para la reproducibilidad
set.seed(12345)
# Definir parámetros para cada cobertura
# coberturas <- list(
#   list(P_min = 0.01, P_esp = 0.05, P_max = 0.10, I_min = 10000, I_prob = 50000, I_max = 100000,Frecuencia=2),
#   list(P_min = 0.02, P_esp = 0.06, P_max = 0.12, I_min = 20000, I_prob = 60000, I_max = 120000,Frecuencia=1),
#   list(P_min = 0.03, P_esp = 0.07, P_max = 0.14, I_min = 30000, I_prob = 70000, I_max = 140000,Frecuencia=3),
#   list(P_min = 0.04, P_esp = 0.08, P_max = 0.16, I_min = 40000, I_prob = 80000, I_max = 160000,Frecuencia=2),
#   list(P_min = 0.05, P_esp = 0.09, P_max = 0.18, I_min = 50000, I_prob = 90000, I_max = 180000,Frecuencia=4)
# )

setwd('/Users/E0305878/OneDrive - Ecopetrol S.A/Documentos/Proyectos Analitica/Limite_Responsabilidad')

coberturas_df <- read_excel("Riesgos.xlsx")
coberturas_df <- coberturas_df %>% dplyr::select(colnames(coberturas_df)[2:8])
coberturas<-apply(coberturas_df,1,as.list)

# Número de expuestos
num_expuestos <- 1
Presupuesto<-1000000
# Número de simulaciones
n_sim <- 10000
# Factores adicionales
factor_riesgo <- 1.2  # Por ejemplo, un 20% adicional por riesgo
factor_gastos <- 1.1  # Por ejemplo, un 10% adicional por gastos
factor_legal <- 1.05  # Por ejemplo, un 5% adicional por implicaciones legales
# Función para generar sumas aseguradas por cobertura
generar_sumas_aseguradas <- function(cobertura) {
  prob_sim <- rtriangle(n_sim, cobertura$P_min, cobertura$P_max, cobertura$P_esp)
  impact_sim <- rtriangle(n_sim, cobertura$I_min*cobertura$Frecuencia, cobertura$I_max*cobertura$Frecuencia, cobertura$I_esp*cobertura$Frecuencia)
  return(prob_sim * impact_sim)
}
# Generar sumas aseguradas para cada cobertura y sumar
suma_asegurada_total <- rowSums(sapply(coberturas, generar_sumas_aseguradas))
# Multiplicar por el número de expuestos
suma_asegurada_final <- suma_asegurada_total * num_expuestos
# Aplicar factores adicionales
suma_asegurada_ajustada <- suma_asegurada_final * factor_riesgo * factor_gastos * factor_legal
# Generar percentiles
percentiles <- quantile(suma_asegurada_ajustada, probs = seq(0, 1, 0.01))
# Análisis adicional
mean_suma_asegurada <- mean(suma_asegurada_ajustada)
median_suma_asegurada <- median(suma_asegurada_ajustada)
sd_suma_asegurada <- sd(suma_asegurada_ajustada)
# Percentiles específicos para las líneas horizontales
percentil_75 <- quantile(suma_asegurada_ajustada, 0.75)
percentil_90 <- quantile(suma_asegurada_ajustada, 0.90)
# Mostrar resultados de análisis
print(paste("Promedio de la Suma Asegurada Ajustada: ", mean_suma_asegurada))
print(paste("Mediana de la Suma Asegurada Ajustada: ", median_suma_asegurada))
print(paste("Desviación Estándar de la Suma Asegurada Ajustada: ", sd_suma_asegurada))
print(paste("Porcentaje aceptable: ", mean_suma_asegurada/Presupuesto))
# Gráfica de la distribución de la suma asegurada ajustada con líneas verticales y leyenda
ggplot(data.frame(suma_asegurada_ajustada), aes(x=suma_asegurada_ajustada)) +
  geom_histogram(binwidth=1000, fill="blue", color="black", alpha=0.7) +
  geom_vline(aes(xintercept=mean_suma_asegurada), color="red", linetype="dashed", size=1, show.legend=TRUE) +
  #geom_vline(aes(xintercept=median_suma_asegurada), color="green", linetype="dashed", size=1, show.legend=TRUE) +
  labs(title="Distribución de la Suma Asegurada Ajustada",
       x="Suma Asegurada Ajustada",
       y="Frecuencia") +
  theme_minimal() +
  theme(legend.position="top") +
  scale_color_manual(name="Líneas de Referencia", values=c("Promedio"="red", "Mediana"="green")) +
  guides(color=guide_legend(override.aes=list(linetype=c("dashed", "dashed"), size=c(1, 1))))

# Gráfica de los percentiles con línea horizontal en el percentil 50 (mediana)
percentiles_df <- data.frame(Percentiles = seq(0, 100, 1), Suma_Asegurada = percentiles)
ggplot(percentiles_df, aes(x=Percentiles, y=Suma_Asegurada)) +
  geom_line(color="blue") +
  #geom_hline(aes(yintercept=median_suma_asegurada), color="red", linetype="dashed", size=1, show.legend=TRUE) +
  geom_hline(aes(yintercept=percentil_75), color="green", linetype="dashed", size=1, show.legend=TRUE) +
  geom_hline(aes(yintercept=percentil_90), color="purple", linetype="dashed", size=1, show.legend=TRUE) +
  labs(title="Curva de Percentiles de la Suma Asegurada Ajustada",
       x="Percentil",
       y="Suma Asegurada") +
  theme_minimal() +
  theme(legend.position="top") +
  scale_color_manual(name="Líneas de Referencia", values=c("Mediana"="red", "Percentil 25"="green", "Percentil 75"="purple")) +
  guides(color=guide_legend(override.aes=list(linetype=c("dashed", "dashed", "dashed"), size=c(1, 1, 1))))

# Boxplot para visualizar la dispersión de la suma asegurada ajustada con línea horizontal en el promedio
ggplot(data.frame(suma_asegurada_ajustada), aes(x="", y=suma_asegurada_ajustada)) +
  geom_boxplot(fill="blue", alpha=0.7) +
  #geom_hline(aes(yintercept=mean_suma_asegurada), color="red", linetype="dashed", size=1, show.legend=TRUE) +
  labs(title="Boxplot de la Suma Asegurada Ajustada",
       y="Suma Asegurada Ajustada") +
  theme_minimal() +
  theme(legend.position="top") +
  scale_color_manual(name="Líneas de Referencia", values=c("Promedio"="red")) +
  guides(color=guide_legend(override.aes=list(linetype="dashed", size=1)))

# Analisis sensibilidad de los factores
########################

# Definir rangos para los factores de sensibilidad
factor_riesgo_rango <- seq(1.0, 1.4, by=0.1)
factor_gastos_rango <- seq(1.0, 1.2, by=0.05)
factor_legal_rango <- seq(1.0, 1.1, by=0.02)
# Crear una combinación de todos los factores
combinaciones <- expand.grid(factor_riesgo_rango, factor_gastos_rango, factor_legal_rango)
colnames(combinaciones) <- c("FactorRiesgo", "FactorGastos", "FactorLegal")
# Función para calcular la suma asegurada ajustada para una combinación de factores
calcular_suma_asegurada_ajustada <- function(factor_riesgo, factor_gastos, factor_legal) {
  suma_asegurada_ajustada <- suma_asegurada_final * factor_riesgo * factor_gastos * factor_legal
  mean_suma <- mean(suma_asegurada_ajustada)
  median_suma <- median(suma_asegurada_ajustada)
  sd_suma <- sd(suma_asegurada_ajustada)
  percentiles <- quantile(suma_asegurada_ajustada, probs = c(0.75,0.8,0.9,0.95))
  return(c(mean_suma, median_suma, sd_suma, percentiles[1], percentiles[2],percentiles[3],percentiles[4]))
}


# Aplicar la función a cada combinación de factores y almacenar los resultados
resultados <- t(apply(combinaciones, 1, function(x) calcular_suma_asegurada_ajustada(x[1], x[2], x[3])))
# Añadir los resultados al DataFrame de combinaciones
resultados_df <- cbind(combinaciones, resultados)
colnames(resultados_df) <- c("FactorRiesgo", "FactorGastos", "FactorLegal", "Promedio", "Mediana", "DesviacionEstandar", "Percentil_75", "Percentil_80","Percentil_90","Percentil_95")
# Mostrar el DataFrame de resultados
print(resultados_df)

# **Gráficas 3D:** Para una visualización más completa de la relación entre los tres factores y los resultados.
library(plotly)
plot_ly(data = resultados_df, x = ~FactorRiesgo, y = ~FactorGastos, z = ~Promedio, color = ~FactorLegal, colors = colorRamp(c("blue", "red")),
        type = "scatter3d", mode = "markers") %>%
  layout(title = "Análisis de Sensibilidad 3D del Promedio",
         scene = list(xaxis = list(title = "Factor Riesgo"),
                      yaxis = list(title = "Factor Gastos"),
                      zaxis = list(title = "Promedio")))
